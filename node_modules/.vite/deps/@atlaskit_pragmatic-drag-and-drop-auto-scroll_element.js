import "./chunk-7OTEKJEF.js";
import "./chunk-WZEM4RIL.js";
import {
  getElementFromPointWithoutHoneypot,
  monitorForElements
} from "./chunk-4T3FREZY.js";
import {
  combine
} from "./chunk-ES4OFIRT.js";
import {
  _defineProperty
} from "./chunk-IECM3HDX.js";
import "./chunk-XIU6KBAU.js";
import "./chunk-4B2QHNJT.js";

// node_modules/.pnpm/@atlaskit+pragmatic-drag-and-drop-auto-scroll@2.1.0/node_modules/@atlaskit/pragmatic-drag-and-drop-auto-scroll/dist/esm/shared/engagement-history.js
var ledger = /* @__PURE__ */ new Map();
var requested = /* @__PURE__ */ new Set();
function markAndGetEngagement(element) {
  markEngagement(element);
  var entry = ledger.get(element);
  if (entry) {
    return entry;
  }
  var fresh = {
    timeOfEngagementStart: Date.now()
  };
  ledger.set(element, fresh);
  return fresh;
}
function markEngagement(element) {
  requested.add(element);
}
function clearUnusedEngagements(fn) {
  requested.clear();
  fn();
  ledger.forEach(function(_, element) {
    if (!requested.has(element)) {
      ledger.delete(element);
    }
  });
  requested.clear();
}
function clearEngagementHistory() {
  ledger.clear();
}

// node_modules/.pnpm/@atlaskit+pragmatic-drag-and-drop-auto-scroll@2.1.0/node_modules/@atlaskit/pragmatic-drag-and-drop-auto-scroll/dist/esm/shared/scheduler.js
var schedulers = /* @__PURE__ */ new Map();
function getScheduler(monitor) {
  var scheduler = schedulers.get(monitor);
  if (scheduler) {
    return scheduler;
  }
  var created = makeScheduler(monitor);
  schedulers.set(monitor, created);
  return created;
}
function makeScheduler(monitor) {
  var state = {
    type: "idle"
  };
  var callbacks = [];
  function loop(timeLastFrameFinished) {
    if (state.type !== "running") {
      return;
    }
    var timeSinceLastFrame = timeLastFrameFinished - state.timeLastFrameFinished;
    var _state = state, latestArgs = _state.latestArgs;
    var underUsersPointer = getElementFromPointWithoutHoneypot({
      x: latestArgs.location.current.input.clientX,
      y: latestArgs.location.current.input.clientY
    });
    clearUnusedEngagements(function() {
      callbacks.forEach(function(onFrame) {
        return onFrame({
          underUsersPointer,
          latestArgs,
          timeSinceLastFrame
        });
      });
    });
    state.timeLastFrameFinished = timeLastFrameFinished;
    state.frameId = requestAnimationFrame(loop);
  }
  function reset() {
    if (state.type === "idle") {
      return;
    }
    cancelAnimationFrame(state.frameId);
    clearEngagementHistory();
    state = {
      type: "idle"
    };
  }
  function start(args) {
    if (state.type !== "idle") {
      return;
    }
    state = {
      // Waiting a frame so we can accurately determine `timeSinceLastFrame`.
      type: "initializing",
      latestArgs: args,
      frameId: requestAnimationFrame(function(timeLastFrameFinished) {
        if (state.type !== "initializing") {
          return;
        }
        state = {
          type: "running",
          timeLastFrameFinished,
          latestArgs: state.latestArgs,
          frameId: requestAnimationFrame(loop)
        };
      })
    };
  }
  function update(args) {
    if (state.type === "idle") {
      start(args);
      return;
    }
    state.latestArgs = args;
  }
  monitor({
    onDragStart: start,
    onDropTargetChange: update,
    onDrag: update,
    onDrop: reset
  });
  var api2 = {
    onFrame: function onFrame(fn) {
      callbacks.push(fn);
    }
  };
  return api2;
}

// node_modules/.pnpm/@atlaskit+pragmatic-drag-and-drop-auto-scroll@2.1.0/node_modules/@atlaskit/pragmatic-drag-and-drop-auto-scroll/dist/esm/over-element/data-attributes.js
var dataAttribute = "data-auto-scrollable";
var selector = "[".concat(dataAttribute, '="true"]');
function addScrollableAttribute(element) {
  element.setAttribute(dataAttribute, "true");
  return function() {
    return element.removeAttribute(dataAttribute);
  };
}

// node_modules/.pnpm/@atlaskit+pragmatic-drag-and-drop-auto-scroll@2.1.0/node_modules/@atlaskit/pragmatic-drag-and-drop-auto-scroll/dist/esm/shared/configuration.js
function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
var baseConfig = {
  startHitboxAtPercentageRemainingOfElement: {
    top: 0.25,
    right: 0.25,
    bottom: 0.25,
    left: 0.25
  },
  maxScrollAtPercentageRemainingOfHitbox: {
    top: 0.5,
    right: 0.5,
    bottom: 0.5,
    left: 0.5
  },
  timeDampeningDurationMs: 400,
  // Too big and it's too easy to trigger auto scrolling
  // Too small and it's too hard ðŸ˜…
  maxMainAxisHitboxSize: 180
};
var maxPixelScrollPerSecond = {
  // What the value would be if we were scrolling at 15px per frame at 60fps.
  // This is the default as it works well for most experiences.
  // In certain scenarios though it can feel a bit slow.
  standard: 15 * 60,
  // What the value would be if we were scrolling at 25px per frame at 60fps.
  // This is not the default as it feels too fast for a lot of experiences.
  fast: 25 * 60
};
function getInternalConfig(provided) {
  var _provided$maxScrollSp;
  return _objectSpread(_objectSpread({}, baseConfig), {}, {
    // only allowing limited control over the config at this stage
    maxPixelScrollPerSecond: maxPixelScrollPerSecond[(_provided$maxScrollSp = provided === null || provided === void 0 ? void 0 : provided.maxScrollSpeed) !== null && _provided$maxScrollSp !== void 0 ? _provided$maxScrollSp : "standard"]
  });
}

// node_modules/.pnpm/@atlaskit+pragmatic-drag-and-drop-auto-scroll@2.1.0/node_modules/@atlaskit/pragmatic-drag-and-drop-auto-scroll/dist/esm/shared/can-scroll-on-edge.js
var canScrollOnEdge = {
  // Notes:
  //
  // ðŸŒ Chrome 115.0: uses fractional units for `scrollLeft` and `scrollTop`
  //    (and fractional units don't reach true integer maximum when zoomed in / out)
  // ðŸŽ Safari 16.5.2: no fractional units
  // ðŸ¦Š Firefox 115.0: no fractional units
  // we have some scroll we can move backwards into
  top: function top(element) {
    return element.scrollTop > 0;
  },
  // We have some scroll we can move forward into
  right: function right(element) {
    return Math.ceil(element.scrollLeft) + element.clientWidth < element.scrollWidth;
  },
  // We have some scroll we can move forwards into
  bottom: function bottom(element) {
    return Math.ceil(element.scrollTop) + element.clientHeight < element.scrollHeight;
  },
  // we have some scroll we can move back into.
  left: function left(element) {
    return element.scrollLeft > 0;
  }
};

// node_modules/.pnpm/@atlaskit+pragmatic-drag-and-drop-auto-scroll@2.1.0/node_modules/@atlaskit/pragmatic-drag-and-drop-auto-scroll/dist/esm/shared/edges.js
var edges = ["top", "right", "bottom", "left"];
var edgeAxisLookup = {
  top: "vertical",
  right: "horizontal",
  bottom: "vertical",
  left: "horizontal"
};

// node_modules/.pnpm/@atlaskit+pragmatic-drag-and-drop-auto-scroll@2.1.0/node_modules/@atlaskit/pragmatic-drag-and-drop-auto-scroll/dist/esm/shared/axis.js
var vertical = {
  start: "top",
  end: "bottom",
  point: "y",
  size: "height"
};
var horizontal = {
  start: "left",
  end: "right",
  point: "x",
  size: "width"
};
var axisLookup = {
  vertical: {
    mainAxis: vertical,
    crossAxis: horizontal
  },
  horizontal: {
    mainAxis: horizontal,
    crossAxis: vertical
  }
};

// node_modules/.pnpm/@atlaskit+pragmatic-drag-and-drop-auto-scroll@2.1.0/node_modules/@atlaskit/pragmatic-drag-and-drop-auto-scroll/dist/esm/shared/side.js
var mainAxisSideLookup = {
  top: "start",
  right: "end",
  bottom: "end",
  left: "start"
};

// node_modules/.pnpm/@atlaskit+pragmatic-drag-and-drop-auto-scroll@2.1.0/node_modules/@atlaskit/pragmatic-drag-and-drop-auto-scroll/dist/esm/shared/get-over-element-hitbox.js
function makeGetHitbox(_ref) {
  var edge = _ref.edge, axis = _ref.axis;
  return function hitbox(_ref2) {
    var _DOMRect$fromRect;
    var clientRect = _ref2.clientRect, config = _ref2.config;
    var _axisLookup$axis = axisLookup[axis], mainAxis = _axisLookup$axis.mainAxis, crossAxis = _axisLookup$axis.crossAxis;
    var side = mainAxisSideLookup[edge];
    var mainAxisHitboxSize = Math.min(
      // scale the size of the hitbox down for smaller elements
      config.startHitboxAtPercentageRemainingOfElement[edge] * clientRect[mainAxis.size],
      // Don't let the hitbox grow too big for big elements
      config.maxMainAxisHitboxSize
    );
    return DOMRect.fromRect((_DOMRect$fromRect = {}, _defineProperty(_DOMRect$fromRect, mainAxis.point, side === "start" ? (
      // begin from the start edge and grow inwards
      clientRect[mainAxis.point]
    ) : (
      // begin from inside the end edge and grow towards the end edge
      clientRect[mainAxis.point] + clientRect[mainAxis.size] - mainAxisHitboxSize
    )), _defineProperty(_DOMRect$fromRect, crossAxis.point, clientRect[crossAxis.point]), _defineProperty(_DOMRect$fromRect, mainAxis.size, mainAxisHitboxSize), _defineProperty(_DOMRect$fromRect, crossAxis.size, clientRect[crossAxis.size]), _DOMRect$fromRect));
  };
}
var getOverElementHitbox = {
  top: makeGetHitbox({
    axis: "vertical",
    edge: "top"
  }),
  right: makeGetHitbox({
    axis: "horizontal",
    edge: "right"
  }),
  bottom: makeGetHitbox({
    axis: "vertical",
    edge: "bottom"
  }),
  left: makeGetHitbox({
    axis: "horizontal",
    edge: "left"
  })
};

// node_modules/.pnpm/@atlaskit+pragmatic-drag-and-drop-auto-scroll@2.1.0/node_modules/@atlaskit/pragmatic-drag-and-drop-auto-scroll/dist/esm/shared/get-percentage-in-range.js
function getPercentageInRange(_ref) {
  var startOfRange = _ref.startOfRange, endOfRange = _ref.endOfRange, value = _ref.value;
  var isValid = startOfRange < endOfRange;
  if (!isValid) {
    return 0;
  }
  if (value < startOfRange) {
    return 0;
  }
  if (value > endOfRange) {
    return 1;
  }
  var range = endOfRange - startOfRange;
  return (value - startOfRange) / range;
}

// node_modules/.pnpm/@atlaskit+pragmatic-drag-and-drop-auto-scroll@2.1.0/node_modules/@atlaskit/pragmatic-drag-and-drop-auto-scroll/dist/esm/shared/get-scroll-change.js
function getMaxScrollChange(_ref) {
  var timeSinceLastFrame = _ref.timeSinceLastFrame, config = _ref.config;
  var targetScrollPerMs = config.maxPixelScrollPerSecond / 1e3;
  var proposed = Math.ceil(targetScrollPerMs * timeSinceLastFrame);
  var maximum = config.maxPixelScrollPerSecond / 60;
  return Math.min(proposed, maximum);
}
function getDistanceDampening(_ref2) {
  var client = _ref2.client, axis = _ref2.axis, edge = _ref2.edge, hitbox = _ref2.hitbox, config = _ref2.config;
  var mainAxis = axisLookup[axis].mainAxis;
  var side = mainAxisSideLookup[edge];
  var maxSpeedBuffer = hitbox[mainAxis.size] * config.maxScrollAtPercentageRemainingOfHitbox[edge];
  if (side === "end") {
    return getPercentageInRange({
      startOfRange: hitbox[mainAxis.start],
      endOfRange: hitbox[mainAxis.end] - maxSpeedBuffer,
      value: client[mainAxis.point]
    });
  }
  var raw = getPercentageInRange({
    startOfRange: hitbox[mainAxis.start] + maxSpeedBuffer,
    endOfRange: hitbox[mainAxis.end],
    value: client[mainAxis.point]
  });
  return 1 - raw;
}
function getScrollChange(_ref3) {
  var client = _ref3.client, timeSinceLastFrame = _ref3.timeSinceLastFrame, engagement = _ref3.engagement, axis = _ref3.axis, hitbox = _ref3.hitbox, edge = _ref3.edge, isDistanceDampeningEnabled = _ref3.isDistanceDampeningEnabled, config = _ref3.config;
  var maxScroll = getMaxScrollChange({
    timeSinceLastFrame,
    config
  });
  var percentageDistanceDampening = isDistanceDampeningEnabled ? getDistanceDampening({
    client,
    edge,
    hitbox,
    axis,
    config
  }) : 1;
  var percentageThroughTimeDampening = getPercentageInRange({
    startOfRange: engagement.timeOfEngagementStart,
    endOfRange: engagement.timeOfEngagementStart + config.timeDampeningDurationMs,
    value: Date.now()
  });
  var percentageOfMaxScroll = percentageDistanceDampening * percentageThroughTimeDampening;
  var scroll = Math.max(maxScroll * percentageOfMaxScroll, 1);
  var side = mainAxisSideLookup[edge];
  return side === "end" ? scroll : -1 * scroll;
}

// node_modules/.pnpm/@atlaskit+pragmatic-drag-and-drop-auto-scroll@2.1.0/node_modules/@atlaskit/pragmatic-drag-and-drop-auto-scroll/dist/esm/shared/is-axis-allowed.js
function isAxisAllowed(axis, allowedAxis) {
  return allowedAxis === "all" || axis === allowedAxis;
}

// node_modules/.pnpm/@atlaskit+pragmatic-drag-and-drop-auto-scroll@2.1.0/node_modules/@atlaskit/pragmatic-drag-and-drop-auto-scroll/dist/esm/shared/is-within.js
function isWithin(_ref) {
  var client = _ref.client, clientRect = _ref.clientRect;
  return (
    // is within horizontal bounds
    client.x >= clientRect.x && client.x <= clientRect.x + clientRect.width && // is within vertical bounds
    client.y >= clientRect.y && client.y <= clientRect.y + clientRect.height
  );
}

// node_modules/.pnpm/@atlaskit+pragmatic-drag-and-drop-auto-scroll@2.1.0/node_modules/@atlaskit/pragmatic-drag-and-drop-auto-scroll/dist/esm/over-element/get-scroll-by.js
function getRectDefault(element) {
  return element.getBoundingClientRect();
}
function getScrollBy(_ref) {
  var element = _ref.element, input = _ref.input, timeSinceLastFrame = _ref.timeSinceLastFrame, engagement = _ref.engagement, config = _ref.config, allowedAxis = _ref.allowedAxis, _ref$getRect = _ref.getRect, getRect = _ref$getRect === void 0 ? getRectDefault : _ref$getRect;
  var client = {
    x: input.clientX,
    y: input.clientY
  };
  var clientRect = getRect(element);
  var scrollableEdges = edges.reduce(function(map, edge) {
    var hitbox = getOverElementHitbox[edge]({
      clientRect,
      config
    });
    var axis = edgeAxisLookup[edge];
    if (!isAxisAllowed(axis, allowedAxis)) {
      return map;
    }
    if (!isWithin({
      client,
      clientRect: hitbox
    })) {
      return map;
    }
    if (!canScrollOnEdge[edge](element)) {
      return map;
    }
    map.set(edge, {
      edge,
      hitbox
    });
    return map;
  }, /* @__PURE__ */ new Map());
  var left2 = function() {
    var axis = "horizontal";
    var leftEdge = scrollableEdges.get("left");
    if (leftEdge) {
      return getScrollChange({
        client,
        edge: leftEdge.edge,
        hitbox: leftEdge.hitbox,
        axis,
        timeSinceLastFrame,
        engagement,
        isDistanceDampeningEnabled: true,
        config
      });
    }
    var rightEdge = scrollableEdges.get("right");
    if (rightEdge) {
      return getScrollChange({
        client,
        edge: rightEdge.edge,
        hitbox: rightEdge.hitbox,
        axis,
        timeSinceLastFrame,
        engagement,
        isDistanceDampeningEnabled: true,
        config
      });
    }
    return 0;
  }();
  var top2 = function() {
    var axis = "vertical";
    var bottomEdge = scrollableEdges.get("bottom");
    if (bottomEdge) {
      return getScrollChange({
        client,
        edge: bottomEdge.edge,
        hitbox: bottomEdge.hitbox,
        axis,
        timeSinceLastFrame,
        engagement,
        isDistanceDampeningEnabled: true,
        config
      });
    }
    var topEdge = scrollableEdges.get("top");
    if (topEdge) {
      return getScrollChange({
        client,
        edge: topEdge.edge,
        hitbox: topEdge.hitbox,
        axis,
        timeSinceLastFrame,
        engagement,
        isDistanceDampeningEnabled: true,
        config
      });
    }
    return 0;
  }();
  return {
    left: left2,
    top: top2
  };
}

// node_modules/.pnpm/@atlaskit+pragmatic-drag-and-drop-auto-scroll@2.1.0/node_modules/@atlaskit/pragmatic-drag-and-drop-auto-scroll/dist/esm/over-element/try-scroll.js
function _createForOfIteratorHelper(r, e) {
  var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (!t) {
    if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) {
      t && (r = t);
      var _n = 0, F = function F2() {
      };
      return { s: F, n: function n() {
        return _n >= r.length ? { done: true } : { done: false, value: r[_n++] };
      }, e: function e2(r2) {
        throw r2;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var o, a = true, u = false;
  return { s: function s() {
    t = t.call(r);
  }, n: function n() {
    var r2 = t.next();
    return a = r2.done, r2;
  }, e: function e2(r2) {
    u = true, o = r2;
  }, f: function f() {
    try {
      a || null == t.return || t.return();
    } finally {
      if (u) throw o;
    }
  } };
}
function _unsupportedIterableToArray(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
  }
}
function _arrayLikeToArray(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
function isScrollingAvailable(value) {
  return Boolean(value.top || value.left);
}
function tryScrollElements(_ref) {
  var _container$getConfigu, _container$getAllowed, _container$getAllowed2;
  var target = _ref.target, input = _ref.input, source = _ref.source, findEntry = _ref.findEntry, timeSinceLastFrame = _ref.timeSinceLastFrame, _ref$available = _ref.available, available = _ref$available === void 0 ? {
    top: true,
    left: true
  } : _ref$available;
  if (!isScrollingAvailable(available)) {
    return available;
  }
  if (!target) {
    return available;
  }
  var element = target.closest(selector);
  if (!element) {
    return available;
  }
  var container = findEntry(element);
  if (!container) {
    return available;
  }
  function continueSearchUp() {
    var _element$parentElemen;
    return tryScrollElements({
      target: (_element$parentElemen = element === null || element === void 0 ? void 0 : element.parentElement) !== null && _element$parentElemen !== void 0 ? _element$parentElemen : null,
      findEntry,
      source,
      timeSinceLastFrame,
      input,
      available
    });
  }
  var feedback = {
    input,
    source,
    element
  };
  if (container.canScroll && !container.canScroll(feedback)) {
    return continueSearchUp();
  }
  var engagement = markAndGetEngagement(element);
  var config = getInternalConfig((_container$getConfigu = container.getConfiguration) === null || _container$getConfigu === void 0 ? void 0 : _container$getConfigu.call(container, feedback));
  var allowedAxis = (_container$getAllowed = (_container$getAllowed2 = container.getAllowedAxis) === null || _container$getAllowed2 === void 0 ? void 0 : _container$getAllowed2.call(container, feedback)) !== null && _container$getAllowed !== void 0 ? _container$getAllowed : "all";
  var scrollBy = getScrollBy({
    element,
    engagement,
    input,
    timeSinceLastFrame,
    allowedAxis,
    config
  });
  var scroll = {
    top: 0,
    left: 0
  };
  if (available.top && scrollBy.top !== 0) {
    scroll.top = scrollBy.top;
    available.top = false;
  }
  if (available.left && scrollBy.left !== 0) {
    scroll.left = scrollBy.left;
    available.left = false;
  }
  if (scroll.top !== 0 || scroll.left !== 0) {
    element.scrollBy(scroll);
  }
  return continueSearchUp();
}
function tryScrollWindow(_ref2) {
  var input = _ref2.input, timeSinceLastFrame = _ref2.timeSinceLastFrame, available = _ref2.available, source = _ref2.source, entries = _ref2.entries;
  var element = document.documentElement;
  var feedback = {
    input,
    source,
    element
  };
  var _iterator = _createForOfIteratorHelper(entries), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var _entry$getConfigurati, _entry$getAllowedAxis, _entry$getAllowedAxis2;
      var entry = _step.value;
      if (entry.canScroll && !entry.canScroll(feedback)) {
        continue;
      }
      var engagement = markAndGetEngagement(element);
      var config = getInternalConfig((_entry$getConfigurati = entry.getConfiguration) === null || _entry$getConfigurati === void 0 ? void 0 : _entry$getConfigurati.call(entry, feedback));
      var allowedAxis = (_entry$getAllowedAxis = (_entry$getAllowedAxis2 = entry.getAllowedAxis) === null || _entry$getAllowedAxis2 === void 0 ? void 0 : _entry$getAllowedAxis2.call(entry, feedback)) !== null && _entry$getAllowedAxis !== void 0 ? _entry$getAllowedAxis : "all";
      var scrollBy = getScrollBy({
        element,
        engagement,
        input,
        config,
        allowedAxis,
        getRect: function getRect(element2) {
          return DOMRect.fromRect({
            y: 0,
            x: 0,
            width: element2.clientWidth,
            height: element2.clientHeight
          });
        },
        timeSinceLastFrame
      });
      var scroll = {
        top: available.top ? scrollBy.top : 0,
        left: available.left ? scrollBy.left : 0
      };
      if (scroll.top !== 0 || scroll.left !== 0) {
        element.scrollBy(scroll);
      }
      break;
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
}
function tryScroll(_ref3) {
  var input = _ref3.input, findEntry = _ref3.findEntry, timeSinceLastFrame = _ref3.timeSinceLastFrame, source = _ref3.source, getWindowScrollEntries = _ref3.getWindowScrollEntries, underUsersPointer = _ref3.underUsersPointer;
  var remainder = tryScrollElements({
    target: underUsersPointer,
    timeSinceLastFrame,
    input,
    source,
    findEntry
  });
  if (!isScrollingAvailable(remainder)) {
    return;
  }
  tryScrollWindow({
    input,
    source,
    entries: getWindowScrollEntries(),
    timeSinceLastFrame,
    available: remainder
  });
}

// node_modules/.pnpm/@atlaskit+pragmatic-drag-and-drop-auto-scroll@2.1.0/node_modules/@atlaskit/pragmatic-drag-and-drop-auto-scroll/dist/esm/over-element/make-api.js
function ownKeys2(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread2(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys2(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys2(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function makeApi(_ref) {
  var monitor = _ref.monitor;
  var elementRegistry = /* @__PURE__ */ new Map();
  var windowRegistry = /* @__PURE__ */ new Set();
  function autoScroll(args) {
    if (true) {
      var _window$getComputedSt = window.getComputedStyle(args.element), overflowX = _window$getComputedSt.overflowX, overflowY = _window$getComputedSt.overflowY;
      var isScrollable = overflowX === "auto" || overflowX === "scroll" || overflowY === "auto" || overflowY === "scroll";
      if (!isScrollable) {
        console.warn("Auto scrolling has been attached to an element that appears not to be scrollable", {
          element: args.element,
          overflowX,
          overflowY
        });
      }
    }
    if (true) {
      var existing = elementRegistry.get(args.element);
      if (existing) {
        console.warn("You have already registered autoScrolling on the same element", {
          existing,
          proposed: args
        });
      }
    }
    elementRegistry.set(args.element, args);
    return combine(addScrollableAttribute(args.element), function() {
      return elementRegistry.delete(args.element);
    });
  }
  function autoScrollWindow() {
    var args = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var unique = _objectSpread2({}, args);
    windowRegistry.add(unique);
    return function() {
      return windowRegistry.delete(unique);
    };
  }
  function findEntry(element) {
    var _elementRegistry$get;
    return (_elementRegistry$get = elementRegistry.get(element)) !== null && _elementRegistry$get !== void 0 ? _elementRegistry$get : null;
  }
  function getWindowScrollEntries() {
    return Array.from(windowRegistry);
  }
  function onFrame(_ref2) {
    var latestArgs = _ref2.latestArgs, underUsersPointer = _ref2.underUsersPointer, timeSinceLastFrame = _ref2.timeSinceLastFrame;
    tryScroll({
      input: latestArgs.location.current.input,
      source: latestArgs.source,
      findEntry,
      underUsersPointer,
      timeSinceLastFrame,
      getWindowScrollEntries
    });
  }
  getScheduler(monitor).onFrame(onFrame);
  return {
    autoScroll,
    autoScrollWindow
  };
}

// node_modules/.pnpm/@atlaskit+pragmatic-drag-and-drop-auto-scroll@2.1.0/node_modules/@atlaskit/pragmatic-drag-and-drop-auto-scroll/dist/esm/entry-point/element.js
var api = makeApi({
  monitor: monitorForElements
});
var autoScrollForElements = api.autoScroll;
var autoScrollWindowForElements = api.autoScrollWindow;
export {
  autoScrollForElements,
  autoScrollWindowForElements
};
//# sourceMappingURL=@atlaskit_pragmatic-drag-and-drop-auto-scroll_element.js.map
