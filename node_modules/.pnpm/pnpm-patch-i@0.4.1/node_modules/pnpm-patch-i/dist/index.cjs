'use strict';

const node_path = require('node:path');
const pathe = require('pathe');
const nonSecure = require('nanoid/non-secure');
const execa = require('execa');
const fs = require('fs-extra');
const mm = require('micromatch');
const prompts = require('prompts');
const findUp = require('find-up');
const launch = require('launch-editor');
const c = require('picocolors');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e.default : e; }

const fs__default = /*#__PURE__*/_interopDefaultCompat(fs);
const mm__default = /*#__PURE__*/_interopDefaultCompat(mm);
const prompts__default = /*#__PURE__*/_interopDefaultCompat(prompts);
const launch__default = /*#__PURE__*/_interopDefaultCompat(launch);
const c__default = /*#__PURE__*/_interopDefaultCompat(c);

const nanoid = nonSecure.customAlphabet("1234567890abcdef", 10);
async function startPatch(options) {
  const {
    name,
    sourceDir,
    yes,
    build,
    pnpmOptions = []
  } = options;
  const lockfile = await findUp.findUp("pnpm-lock.yaml");
  if (!lockfile)
    throw new Error("Failed to locate pnpm-lock.yaml");
  const cwd = node_path.dirname(lockfile);
  const editDir = pathe.join(cwd, `node_modules/.patch-edits/patch_edit_${name.replace(/\//g, "+")}_${nanoid()}`);
  await execa.execa("pnpm", ["patch", ...pnpmOptions, "--edit-dir", editDir, name], { stdio: "inherit", cwd });
  if (!sourceDir) {
    await launch__default(editDir);
    if (build)
      throw new Error("--build is not supported when sourceDir is not specified");
    console.log(`Edit your patch for ${c__default.bold(c__default.yellow(name))} under ${c__default.green(editDir)}
`);
    const confirm = yes || await prompts__default([{
      name: "confirm",
      type: "confirm",
      message: "Finish editing and commit the patch?",
      initial: true
    }]).then((r) => r.confirm);
    if (!confirm) {
      console.log(c__default.yellow("\nOperation cancelled"));
      return;
    }
  } else {
    let handleDeps = function(local = {}, overrides) {
      if (!overrides)
        return void 0;
      const extraKeys = Object.keys(local).filter((k) => !Object.keys(overrides).includes(k));
      for (const key of extraKeys)
        delete local[key];
      for (const [key, value] of Object.entries(overrides))
        local[key] = value;
      return local;
    };
    const sourcePath = pathe.resolve(cwd, sourceDir);
    const sourcePkg = await fs__default.readJSON(pathe.join(sourcePath, "package.json"));
    const confirm = yes || await prompts__default([{
      name: "confirm",
      type: "confirm",
      message: `Applying patch from ${sourcePath}?`,
      initial: true
    }]).then((r) => r.confirm);
    if (!confirm) {
      console.log(c__default.yellow("\nOperation cancelled"));
      return;
    }
    if (build)
      await execa.execa("npm", ["run", "build"], { stdio: "inherit", cwd: sourcePath });
    const glob = sourcePkg.files ? sourcePkg.files.flatMap((i) => i.includes("*") ? [i] : [i, `${i}/**`]) : void 0;
    const filter = (src) => {
      const relativePath = pathe.relative(sourcePath, src);
      if (!relativePath)
        return true;
      if (relativePath.includes("node_modules") || relativePath === "package.json")
        return false;
      if (glob)
        return mm__default.isMatch(relativePath, glob);
      return true;
    };
    console.log(c__default.blue("\nApplying patch..."));
    await fs__default.copy(sourcePath, editDir, {
      overwrite: true,
      filter: (src) => {
        const result = filter(src);
        if (result)
          console.log(c__default.green(`  ${src}`));
        return result;
      }
    });
    const localPkg = await fs__default.readJSON(pathe.join(editDir, "package.json"));
    if (sourcePkg.dependencies)
      localPkg.dependencies = handleDeps(localPkg.dependencies, sourcePkg.dependencies);
    if (sourcePkg.devDependencies)
      localPkg.devDependencies = handleDeps(localPkg.devDependencies, sourcePkg.devDependencies);
    if (sourcePkg.peerDependencies)
      localPkg.peerDependencies = handleDeps(localPkg.peerDependencies, sourcePkg.peerDependencies);
    if (sourcePkg.optionalDependencies)
      localPkg.optionalDependencies = handleDeps(localPkg.optionalDependencies, sourcePkg.optionalDependencies);
    await fs__default.writeJSON(pathe.join(editDir, "package.json"), localPkg, { spaces: 2 });
  }
  console.log(c__default.blue("\nCommiting patch..."));
  await execa.execa("pnpm", ["patch-commit", editDir], { stdio: "inherit", cwd });
}

exports.startPatch = startPatch;
