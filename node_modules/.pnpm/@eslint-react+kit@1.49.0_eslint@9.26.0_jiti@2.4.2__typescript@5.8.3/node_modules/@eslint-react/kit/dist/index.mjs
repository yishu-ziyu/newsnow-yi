import { dual, getOrElseUpdate } from '@eslint-react/eff';
import * as z from '@zod/mini';

var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// src/JsxConfig/index.ts
var JsxConfig_exports = {};
__export(JsxConfig_exports, {
  JsxEmit: () => JsxEmit,
  getFromAnnotation: () => getFromAnnotation,
  getFromContext: () => getFromContext,
  make: () => make
});

// src/RegExp.ts
var RegExp_exports = {};
__export(RegExp_exports, {
  ANNOTATION_JSX: () => ANNOTATION_JSX,
  ANNOTATION_JSX_FRAG: () => ANNOTATION_JSX_FRAG,
  ANNOTATION_JSX_IMPORT_SOURCE: () => ANNOTATION_JSX_IMPORT_SOURCE,
  ANNOTATION_JSX_RUNTIME: () => ANNOTATION_JSX_RUNTIME,
  CAMEL_CASE: () => CAMEL_CASE,
  COMPONENT_NAME: () => COMPONENT_NAME,
  COMPONENT_NAME_LOOSE: () => COMPONENT_NAME_LOOSE,
  CONSTANT_CASE: () => CONSTANT_CASE,
  HOOK_NAME: () => HOOK_NAME,
  HTML_TAG: () => HTML_TAG,
  JAVASCRIPT_PROTOCOL: () => JAVASCRIPT_PROTOCOL,
  JS_EXT: () => JS_EXT,
  JS_IDENTIFIER: () => JS_IDENTIFIER,
  KEBAB_CASE: () => KEBAB_CASE,
  PASCAL_CASE: () => PASCAL_CASE,
  REGEXP_STR: () => REGEXP_STR,
  SNAKE_CASE: () => SNAKE_CASE,
  TS_EXT: () => TS_EXT,
  isRegExp: () => isRegExp,
  toRegExp: () => toRegExp
});
var HTML_TAG = /^[a-z][^-]*$/u;
var TS_EXT = /^[cm]?tsx?$/u;
var JS_EXT = /^[cm]?jsx?$/u;
var PASCAL_CASE = /^[A-Z][\dA-Za-z]*$/u;
var CAMEL_CASE = /^[a-z][\dA-Za-z]*$/u;
var KEBAB_CASE = /^[a-z][\d\-a-z]*$/u;
var SNAKE_CASE = /^[a-z][\d_a-z]*$/u;
var CONSTANT_CASE = /^[A-Z][\d_A-Z]*$/u;
var JAVASCRIPT_PROTOCOL = /^[\u0000-\u001F ]*j[\t\n\r]*a[\t\n\r]*v[\t\n\r]*a[\t\n\r]*s[\t\n\r]*c[\t\n\r]*r[\t\n\r]*i[\t\n\r]*p[\t\n\r]*t[\t\n\r]*:/iu;
var JS_IDENTIFIER = /^[_$a-z][\w$]*$/i;
var REGEXP_STR = /^\/(.+)\/([A-Za-z]*)$/u;
var ANNOTATION_JSX = /@jsx\s+(\S+)/u;
var ANNOTATION_JSX_FRAG = /@jsxFrag\s+(\S+)/u;
var ANNOTATION_JSX_RUNTIME = /@jsxRuntime\s+(\S+)/u;
var ANNOTATION_JSX_IMPORT_SOURCE = /@jsxImportSource\s+(\S+)/u;
var COMPONENT_NAME = /^[A-Z]/u;
var COMPONENT_NAME_LOOSE = /^_?[A-Z]/u;
var HOOK_NAME = /^use/u;
function toRegExp(string) {
  const [, pattern, flags = "u"] = REGEXP_STR.exec(string) ?? [];
  if (pattern != null) return new RegExp(pattern, flags);
  return { test: (s) => s === string };
}
function isRegExp(string) {
  return Boolean(REGEXP_STR.test(string));
}

// src/JsxConfig/JsxConfig.ts
var JsxEmit = {
  None: 0,
  Preserve: 1,
  React: 2,
  ReactNative: 3,
  ReactJSX: 4,
  ReactJSXDev: 5
};
function make() {
  return {};
}
function getFromContext(context) {
  const options = context.sourceCode.parserServices?.program?.getCompilerOptions() ?? {};
  return {
    jsx: options.jsx ?? JsxEmit.ReactJSX,
    jsxFactory: options.jsxFactory ?? "React.createElement",
    jsxFragmentFactory: options.jsxFragmentFactory ?? "React.Fragment",
    jsxImportSource: options.jsxImportSource ?? "react",
    reactNamespace: options.reactNamespace ?? "React"
  };
}
var cache = /* @__PURE__ */ new WeakMap();
function getFromAnnotation(context) {
  return getOrElseUpdate(
    cache,
    context.sourceCode,
    () => {
      const options = make();
      if (!context.sourceCode.text.includes("@jsx")) return options;
      let jsx, jsxFrag, jsxRuntime, jsxImportSource;
      for (const comment of context.sourceCode.getAllComments().reverse()) {
        const value = comment.value;
        jsx ??= value.match(ANNOTATION_JSX)?.[1];
        jsxFrag ??= value.match(ANNOTATION_JSX_FRAG)?.[1];
        jsxRuntime ??= value.match(ANNOTATION_JSX_RUNTIME)?.[1];
        jsxImportSource ??= value.match(ANNOTATION_JSX_IMPORT_SOURCE)?.[1];
      }
      if (jsx != null) options.jsxFactory = jsx;
      if (jsxFrag != null) options.jsxFragmentFactory = jsxFrag;
      if (jsxRuntime != null) options.jsx = jsxRuntime === "classic" ? JsxEmit.React : JsxEmit.ReactJSX;
      if (jsxImportSource != null) options.jsxImportSource = jsxImportSource;
      return options;
    }
  );
}

// src/LanguagePreference/index.ts
var LanguagePreference_exports = {};
__export(LanguagePreference_exports, {
  LanguagePreferenceSchema: () => LanguagePreferenceSchema,
  getFromContext: () => getFromContext2,
  make: () => make2
});

// src/LanguagePreference/LanguagePreference.ts
function make2() {
  return {
    indentStyle: "space",
    indentWidth: 2,
    jsxQuoteStyle: "double",
    quoteStyle: "single",
    semicolons: "always",
    trailingCommas: "all"
  };
}
function getFromContext2() {
  throw new Error("getFromContext is not implemented");
}
var LanguagePreferenceSchema = z.object({
  indentStyle: z.optional(
    z.union([
      z.literal("tab"),
      z.literal("space")
    ])
  ),
  indentWidth: z.optional(z.number()),
  quoteStyle: z.optional(
    z.union([
      z.literal("single"),
      z.literal("double")
    ])
  ),
  semicolons: z.optional(
    z.union([
      z.literal("always"),
      z.literal("asNeeded")
    ])
  ),
  trailingCommas: z.optional(
    z.union([
      z.literal("all"),
      z.literal("es5"),
      z.literal("none")
    ])
  ),
  // JSX specific options
  jsxQuoteStyle: z.optional(
    z.union([
      z.literal("single"),
      z.literal("double")
    ])
  )
}, {});

// src/Reporter.ts
var Reporter_exports = {};
__export(Reporter_exports, {
  make: () => make3,
  send: () => send,
  sendOrElse: () => sendOrElse
});
var send = dual(2, (context, descriptor) => {
  if (descriptor == null) return;
  return context.report(descriptor);
});
var sendOrElse = dual(3, (context, descriptor, cb) => {
  if (descriptor == null) return cb();
  return context.report(descriptor);
});
function make3(context) {
  return {
    send: (...args) => send(context, ...args),
    sendOrElse: (...args) => sendOrElse(context, ...args)
  };
}

// src/Selector.ts
var Selector_exports = {};
__export(Selector_exports, {
  DISPLAY_NAME_ASSIGNMENT_EXPRESSION: () => DISPLAY_NAME_ASSIGNMENT_EXPRESSION,
  IMPLICIT_RETURN_ARROW_FUNCTION_EXPRESSION: () => IMPLICIT_RETURN_ARROW_FUNCTION_EXPRESSION,
  OBJECT_DESTRUCTURING_VARIABLE_DECLARATOR: () => OBJECT_DESTRUCTURING_VARIABLE_DECLARATOR
});
var IMPLICIT_RETURN_ARROW_FUNCTION_EXPRESSION = "ArrowFunctionExpression[body.type!='BlockStatement']";
var OBJECT_DESTRUCTURING_VARIABLE_DECLARATOR = [
  "VariableDeclarator",
  "[id.type='ObjectPattern']",
  "[init.type='Identifier']"
].join("");
var DISPLAY_NAME_ASSIGNMENT_EXPRESSION = [
  "AssignmentExpression",
  "[operator='=']",
  "[left.type='MemberExpression']",
  "[left.property.name='displayName']"
].join("");

export { JsxConfig_exports as JsxConfig, LanguagePreference_exports as LanguagePreference, RegExp_exports as RegExp, Reporter_exports as Reporter, Selector_exports as Selector };
