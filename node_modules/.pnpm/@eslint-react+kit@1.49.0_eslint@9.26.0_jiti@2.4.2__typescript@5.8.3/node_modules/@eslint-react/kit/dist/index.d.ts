import * as typescript from 'typescript';
import * as tseslint from '@typescript-eslint/utils/ts-eslint';
import { ReportDescriptor } from '@typescript-eslint/utils/ts-eslint';
import * as z from '@zod/mini';
import { _ } from '@eslint-react/eff';
import { TSESTree } from '@typescript-eslint/utils';

/**
 * Rule severity.
 * @since 0.0.1
 */
type RuleSeverity = "error" | "off" | "warn";
/**
 * Rule declaration.
 * @internal
 * @since 0.0.1
 */
type RuleDeclaration = [RuleSeverity, Record<string, unknown>?] | RuleSeverity;
/**
 * Rule config preset.
 * @since 0.0.1
 */
type RulePreset = Record<string, RuleDeclaration>;
/**
 * Rule context.
 * @since 0.0.1
 */
type RuleContext<MessageIds extends string = string, Options extends readonly unknown[] = readonly unknown[]> = tseslint.RuleContext<MessageIds, Options>;
/**
 * Rule feature.
 * @since 1.20.0
 */
type RuleFeature = "CFG" | "DBG" | "FIX" | "MOD" | "TSC" | "EXP";

declare const JsxEmit: {
    readonly None: 0;
    readonly Preserve: 1;
    readonly React: 2;
    readonly ReactNative: 3;
    readonly ReactJSX: 4;
    readonly ReactJSXDev: 5;
};
interface JsxConfig {
    jsx?: number;
    jsxFactory?: string;
    jsxFragmentFactory?: string;
    jsxImportSource?: string;
}
/**
 * Create a JsxConfig object
 * @returns JsxConfig
 */
declare function make$2(): JsxConfig;
/**
 * Get JsxConfig from RuleContext
 * @param context The RuleContext
 * @returns JsxConfig
 */
declare function getFromContext$1(context: RuleContext): {
    jsx: 4 | typescript.JsxEmit;
    jsxFactory: string;
    jsxFragmentFactory: string;
    jsxImportSource: string;
    reactNamespace: string;
};
/**
 * Get JsxConfig from annotation
 * @param context The RuleContext
 * @returns JsxConfig
 */
declare function getFromAnnotation(context: RuleContext): JsxConfig;

type index$1_JsxConfig = JsxConfig;
declare const index$1_JsxEmit: typeof JsxEmit;
declare const index$1_getFromAnnotation: typeof getFromAnnotation;
declare namespace index$1 {
  export { type index$1_JsxConfig as JsxConfig, index$1_JsxEmit as JsxEmit, index$1_getFromAnnotation as getFromAnnotation, getFromContext$1 as getFromContext, make$2 as make };
}

/**
 * @internal
 */
declare const LanguagePreferenceSchema: z.ZodMiniObject<{
    indentStyle: z.ZodMiniOptional<z.ZodMiniUnion<readonly [z.ZodMiniLiteral<"tab">, z.ZodMiniLiteral<"space">]>>;
    indentWidth: z.ZodMiniOptional<z.ZodMiniNumber<number>>;
    quoteStyle: z.ZodMiniOptional<z.ZodMiniUnion<readonly [z.ZodMiniLiteral<"single">, z.ZodMiniLiteral<"double">]>>;
    semicolons: z.ZodMiniOptional<z.ZodMiniUnion<readonly [z.ZodMiniLiteral<"always">, z.ZodMiniLiteral<"asNeeded">]>>;
    trailingCommas: z.ZodMiniOptional<z.ZodMiniUnion<readonly [z.ZodMiniLiteral<"all">, z.ZodMiniLiteral<"es5">, z.ZodMiniLiteral<"none">]>>;
    jsxQuoteStyle: z.ZodMiniOptional<z.ZodMiniUnion<readonly [z.ZodMiniLiteral<"single">, z.ZodMiniLiteral<"double">]>>;
}, {}>;

/**
 * @internal
 */
type LanguagePreference = z.infer<typeof LanguagePreferenceSchema>;
/**
 * Get a copy of the default LanguagePreference.
 */
declare function make$1(): LanguagePreference;
declare function getFromContext(): void;
declare module "@typescript-eslint/utils/ts-eslint" {
    interface SharedConfigurationSettings {
    }
}

type index_LanguagePreference = LanguagePreference;
declare const index_LanguagePreferenceSchema: typeof LanguagePreferenceSchema;
declare const index_getFromContext: typeof getFromContext;
declare namespace index {
  export { type index_LanguagePreference as LanguagePreference, index_LanguagePreferenceSchema as LanguagePreferenceSchema, index_getFromContext as getFromContext, make$1 as make };
}

/**
 * Regular expressions for matching a HTML tag name
 */
declare const HTML_TAG: RegExp;
/**
 * Regular expression for matching a TypeScript file extension.
 */
declare const TS_EXT: RegExp;
/**
 * Regular expression for matching a JavaScript file extension.
 */
declare const JS_EXT: RegExp;
/**
 * Regular expression for matching a PascalCase string.
 */
declare const PASCAL_CASE: RegExp;
/**
 * Regular expression for matching a camelCase string.
 */
declare const CAMEL_CASE: RegExp;
/**
 * Regular expression for matching a kebab-case string.
 */
declare const KEBAB_CASE: RegExp;
/**
 * Regular expression for matching a snake_case string.
 */
declare const SNAKE_CASE: RegExp;
/**
 * Regular expression for matching a CONSTANT_CASE string.
 */
declare const CONSTANT_CASE: RegExp;
declare const JAVASCRIPT_PROTOCOL: RegExp;
/**
 * Regular expression for matching a valid JavaScript identifier.
 */
declare const JS_IDENTIFIER: RegExp;
/**
 * Regular expression for matching a RegExp string.
 */
declare const REGEXP_STR: RegExp;
/**
 * Regular expression for matching a `@jsx` annotation comment.
 */
declare const ANNOTATION_JSX: RegExp;
/**
 * Regular expression for matching a `@jsxFrag` annotation comment.
 */
declare const ANNOTATION_JSX_FRAG: RegExp;
/**
 * Regular expression for matching a `@jsxRuntime` annotation comment.
 */
declare const ANNOTATION_JSX_RUNTIME: RegExp;
/**
 * Regular expression for matching a `@jsxImportSource` annotation comment.
 */
declare const ANNOTATION_JSX_IMPORT_SOURCE: RegExp;
/**
 * Regular expression for matching a React component name.
 */
declare const COMPONENT_NAME: RegExp;
/**
 * Regular expression for matching a React component name (loose).
 */
declare const COMPONENT_NAME_LOOSE: RegExp;
/**
 * Regular expression for matching a React Hook name.
 */
declare const HOOK_NAME: RegExp;
/**
 * Convert a string to the `RegExp`.
 * Normal strings (e.g. `"foo"`) is converted to `/^foo$/` of `RegExp`.
 * Strings like `"/^foo/i"` are converted to `/^foo/i` of `RegExp`.
 * @see https://github.com/sveltejs/eslint-plugin-svelte/blob/main/packages/eslint-plugin-svelte/src/utils/regexp.ts
 * @param string The string to convert.
 * @returns Returns the `RegExp`.
 */
declare function toRegExp(string: string): {
    test(s: string): boolean;
};
/**
 * Checks whether given string is regexp string
 * @param string The string to check
 * @returns boolean
 */
declare function isRegExp(string: string): boolean;

declare const RegExp$1_ANNOTATION_JSX: typeof ANNOTATION_JSX;
declare const RegExp$1_ANNOTATION_JSX_FRAG: typeof ANNOTATION_JSX_FRAG;
declare const RegExp$1_ANNOTATION_JSX_IMPORT_SOURCE: typeof ANNOTATION_JSX_IMPORT_SOURCE;
declare const RegExp$1_ANNOTATION_JSX_RUNTIME: typeof ANNOTATION_JSX_RUNTIME;
declare const RegExp$1_CAMEL_CASE: typeof CAMEL_CASE;
declare const RegExp$1_COMPONENT_NAME: typeof COMPONENT_NAME;
declare const RegExp$1_COMPONENT_NAME_LOOSE: typeof COMPONENT_NAME_LOOSE;
declare const RegExp$1_CONSTANT_CASE: typeof CONSTANT_CASE;
declare const RegExp$1_HOOK_NAME: typeof HOOK_NAME;
declare const RegExp$1_HTML_TAG: typeof HTML_TAG;
declare const RegExp$1_JAVASCRIPT_PROTOCOL: typeof JAVASCRIPT_PROTOCOL;
declare const RegExp$1_JS_EXT: typeof JS_EXT;
declare const RegExp$1_JS_IDENTIFIER: typeof JS_IDENTIFIER;
declare const RegExp$1_KEBAB_CASE: typeof KEBAB_CASE;
declare const RegExp$1_PASCAL_CASE: typeof PASCAL_CASE;
declare const RegExp$1_REGEXP_STR: typeof REGEXP_STR;
declare const RegExp$1_SNAKE_CASE: typeof SNAKE_CASE;
declare const RegExp$1_TS_EXT: typeof TS_EXT;
declare const RegExp$1_isRegExp: typeof isRegExp;
declare const RegExp$1_toRegExp: typeof toRegExp;
declare namespace RegExp$1 {
  export { RegExp$1_ANNOTATION_JSX as ANNOTATION_JSX, RegExp$1_ANNOTATION_JSX_FRAG as ANNOTATION_JSX_FRAG, RegExp$1_ANNOTATION_JSX_IMPORT_SOURCE as ANNOTATION_JSX_IMPORT_SOURCE, RegExp$1_ANNOTATION_JSX_RUNTIME as ANNOTATION_JSX_RUNTIME, RegExp$1_CAMEL_CASE as CAMEL_CASE, RegExp$1_COMPONENT_NAME as COMPONENT_NAME, RegExp$1_COMPONENT_NAME_LOOSE as COMPONENT_NAME_LOOSE, RegExp$1_CONSTANT_CASE as CONSTANT_CASE, RegExp$1_HOOK_NAME as HOOK_NAME, RegExp$1_HTML_TAG as HTML_TAG, RegExp$1_JAVASCRIPT_PROTOCOL as JAVASCRIPT_PROTOCOL, RegExp$1_JS_EXT as JS_EXT, RegExp$1_JS_IDENTIFIER as JS_IDENTIFIER, RegExp$1_KEBAB_CASE as KEBAB_CASE, RegExp$1_PASCAL_CASE as PASCAL_CASE, RegExp$1_REGEXP_STR as REGEXP_STR, RegExp$1_SNAKE_CASE as SNAKE_CASE, RegExp$1_TS_EXT as TS_EXT, RegExp$1_isRegExp as isRegExp, RegExp$1_toRegExp as toRegExp };
}

interface Reporter<TMessageID extends string> {
    send: (descriptor: _ | null | ReportDescriptor<TMessageID>) => void;
    sendOrElse: <TElse>(descriptor: _ | null | ReportDescriptor<TMessageID>, cb: () => TElse) => _ | TElse;
}
declare const send: {
    <TMessageID extends string>(context: RuleContext, descriptor: _ | null | ReportDescriptor<TMessageID>): void;
    <TMessageID extends string>(context: RuleContext): (descriptor: _ | null | ReportDescriptor<TMessageID>) => void;
};
declare const sendOrElse: {
    <TMessageID extends string, TElse>(context: RuleContext, descriptor: _ | null | ReportDescriptor<TMessageID>, cb: () => TElse): _ | TElse;
    <TMessageID extends string, TElse>(context: RuleContext): (descriptor: _ | null | ReportDescriptor<TMessageID>) => (cb: () => TElse) => _ | TElse;
};
declare function make<TMessageID extends string>(context: RuleContext): Reporter<TMessageID>;

type Reporter$1_Reporter<TMessageID extends string> = Reporter<TMessageID>;
declare const Reporter$1_make: typeof make;
declare const Reporter$1_send: typeof send;
declare const Reporter$1_sendOrElse: typeof sendOrElse;
declare namespace Reporter$1 {
  export { type Reporter$1_Reporter as Reporter, Reporter$1_make as make, Reporter$1_send as send, Reporter$1_sendOrElse as sendOrElse };
}

type ImplicitReturnArrowFunctionExpression = TSESTree.ArrowFunctionExpression & {
    body: TSESTree.Expression;
};
type ObjectDestructuringVariableDeclarator = TSESTree.VariableDeclarator & {
    id: TSESTree.ObjectPattern;
    init: TSESTree.Identifier;
};
type DisplayNameAssignmentExpression = TSESTree.AssignmentExpression & {
    type: "AssignmentExpression";
    left: TSESTree.MemberExpression & {
        property: TSESTree.Identifier & {
            name: "displayName";
        };
    };
    operator: "=";
    right: TSESTree.Literal;
};
declare const IMPLICIT_RETURN_ARROW_FUNCTION_EXPRESSION = "ArrowFunctionExpression[body.type!='BlockStatement']";
declare const OBJECT_DESTRUCTURING_VARIABLE_DECLARATOR: string;
declare const DISPLAY_NAME_ASSIGNMENT_EXPRESSION: string;

declare const Selector_DISPLAY_NAME_ASSIGNMENT_EXPRESSION: typeof DISPLAY_NAME_ASSIGNMENT_EXPRESSION;
type Selector_DisplayNameAssignmentExpression = DisplayNameAssignmentExpression;
declare const Selector_IMPLICIT_RETURN_ARROW_FUNCTION_EXPRESSION: typeof IMPLICIT_RETURN_ARROW_FUNCTION_EXPRESSION;
type Selector_ImplicitReturnArrowFunctionExpression = ImplicitReturnArrowFunctionExpression;
declare const Selector_OBJECT_DESTRUCTURING_VARIABLE_DECLARATOR: typeof OBJECT_DESTRUCTURING_VARIABLE_DECLARATOR;
type Selector_ObjectDestructuringVariableDeclarator = ObjectDestructuringVariableDeclarator;
declare namespace Selector {
  export { Selector_DISPLAY_NAME_ASSIGNMENT_EXPRESSION as DISPLAY_NAME_ASSIGNMENT_EXPRESSION, type Selector_DisplayNameAssignmentExpression as DisplayNameAssignmentExpression, Selector_IMPLICIT_RETURN_ARROW_FUNCTION_EXPRESSION as IMPLICIT_RETURN_ARROW_FUNCTION_EXPRESSION, type Selector_ImplicitReturnArrowFunctionExpression as ImplicitReturnArrowFunctionExpression, Selector_OBJECT_DESTRUCTURING_VARIABLE_DECLARATOR as OBJECT_DESTRUCTURING_VARIABLE_DECLARATOR, type Selector_ObjectDestructuringVariableDeclarator as ObjectDestructuringVariableDeclarator };
}

export { index$1 as JsxConfig, index as LanguagePreference, RegExp$1 as RegExp, Reporter$1 as Reporter, type RuleContext, type RuleDeclaration, type RuleFeature, type RulePreset, type RuleSeverity, Selector };
