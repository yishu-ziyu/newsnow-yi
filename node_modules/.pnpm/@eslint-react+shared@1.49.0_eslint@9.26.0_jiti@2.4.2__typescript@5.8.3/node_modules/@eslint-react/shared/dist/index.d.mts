import { _ } from '@eslint-react/eff';
import { RuleContext } from '@eslint-react/kit';
import * as z from '@zod/mini';

/**
 * The NPM scope for this project.
 */
declare const NPM_SCOPE = "@eslint-react";
/**
 * The GitHub repository for this project.
 */
declare const GITHUB_URL = "https://github.com/Rel1cx/eslint-react";
/**
 * The URL to the project's website.
 */
declare const WEBSITE_URL = "https://eslint-react.xyz";

/**
 * Get the URL for the documentation of a rule in a plugin.
 * @internal
 * @param pluginName The name of the plugin.
 * @returns The URL for the documentation of a rule.
 */
declare const getDocsUrl: (pluginName: string) => (ruleName: string) => string;

declare const getId: () => string;

declare function getReactVersion(fallback: string): string;

/**
Matches any [primitive value](https://developer.mozilla.org/en-US/docs/Glossary/Primitive).

@category Type
*/
type Primitive =
	| null
	| undefined
	| string
	| number
	| boolean
	| symbol
	| bigint;

declare global {
	// eslint-disable-next-line @typescript-eslint/consistent-type-definitions -- It has to be an `interface` so that it can be merged.
	interface SymbolConstructor {
		readonly observable: symbol;
	}
}

/**
Extract all optional keys from the given type.

This is useful when you want to create a new type that contains different type values for the optional keys only.

@example
```
import type {OptionalKeysOf, Except} from 'type-fest';

interface User {
	name: string;
	surname: string;

	luckyNumber?: number;
}

const REMOVE_FIELD = Symbol('remove field symbol');
type UpdateOperation<Entity extends object> = Except<Partial<Entity>, OptionalKeysOf<Entity>> & {
	[Key in OptionalKeysOf<Entity>]?: Entity[Key] | typeof REMOVE_FIELD;
};

const update1: UpdateOperation<User> = {
	name: 'Alice'
};

const update2: UpdateOperation<User> = {
	name: 'Bob',
	luckyNumber: REMOVE_FIELD
};
```

@category Utilities
*/
type OptionalKeysOf<BaseType extends object> =
	BaseType extends unknown // For distributing `BaseType`
		? (keyof {
			[Key in keyof BaseType as BaseType extends Record<Key, BaseType[Key]> ? never : Key]: never
		}) & (keyof BaseType) // Intersect with `keyof BaseType` to ensure result of `OptionalKeysOf<BaseType>` is always assignable to `keyof BaseType`
		: never; // Should never happen

/**
Extract all required keys from the given type.

This is useful when you want to create a new type that contains different type values for the required keys only or use the list of keys for validation purposes, etc...

@example
```
import type {RequiredKeysOf} from 'type-fest';

declare function createValidation<Entity extends object, Key extends RequiredKeysOf<Entity> = RequiredKeysOf<Entity>>(field: Key, validator: (value: Entity[Key]) => boolean): ValidatorFn;

interface User {
	name: string;
	surname: string;

	luckyNumber?: number;
}

const validator1 = createValidation<User>('name', value => value.length < 25);
const validator2 = createValidation<User>('surname', value => value.length < 25);
```

@category Utilities
*/
type RequiredKeysOf<BaseType extends object> =
	BaseType extends unknown // For distributing `BaseType`
		? Exclude<keyof BaseType, OptionalKeysOf<BaseType>>
		: never; // Should never happen

/**
Returns a boolean for whether the given type is `never`.

@link https://github.com/microsoft/TypeScript/issues/31751#issuecomment-498526919
@link https://stackoverflow.com/a/53984913/10292952
@link https://www.zhenghao.io/posts/ts-never

Useful in type utilities, such as checking if something does not occur.

@example
```
import type {IsNever, And} from 'type-fest';

// https://github.com/andnp/SimplyTyped/blob/master/src/types/strings.ts
type AreStringsEqual<A extends string, B extends string> =
	And<
		IsNever<Exclude<A, B>> extends true ? true : false,
		IsNever<Exclude<B, A>> extends true ? true : false
	>;

type EndIfEqual<I extends string, O extends string> =
	AreStringsEqual<I, O> extends true
		? never
		: void;

function endIfEqual<I extends string, O extends string>(input: I, output: O): EndIfEqual<I, O> {
	if (input === output) {
		process.exit(0);
	}
}

endIfEqual('abc', 'abc');
//=> never

endIfEqual('abc', '123');
//=> void
```

@category Type Guard
@category Utilities
*/
type IsNever<T> = [T] extends [never] ? true : false;

/**
An if-else-like type that resolves depending on whether the given type is `never`.

@see {@link IsNever}

@example
```
import type {IfNever} from 'type-fest';

type ShouldBeTrue = IfNever<never>;
//=> true

type ShouldBeBar = IfNever<'not never', 'foo', 'bar'>;
//=> 'bar'
```

@category Type Guard
@category Utilities
*/
type IfNever<T, TypeIfNever = true, TypeIfNotNever = false> = (
	IsNever<T> extends true ? TypeIfNever : TypeIfNotNever
);

// Can eventually be replaced with the built-in once this library supports
// TS5.4+ only. Tracked in https://github.com/sindresorhus/type-fest/issues/848
type NoInfer<T> = T extends infer U ? U : never;

/**
Returns a boolean for whether the given type is `any`.

@link https://stackoverflow.com/a/49928360/1490091

Useful in type utilities, such as disallowing `any`s to be passed to a function.

@example
```
import type {IsAny} from 'type-fest';

const typedObject = {a: 1, b: 2} as const;
const anyObject: any = {a: 1, b: 2};

function get<O extends (IsAny<O> extends true ? {} : Record<string, number>), K extends keyof O = keyof O>(obj: O, key: K) {
	return obj[key];
}

const typedA = get(typedObject, 'a');
//=> 1

const anyA = get(anyObject, 'a');
//=> any
```

@category Type Guard
@category Utilities
*/
type IsAny<T> = 0 extends 1 & NoInfer<T> ? true : false;

/**
Useful to flatten the type output to improve type hints shown in editors. And also to transform an interface into a type to aide with assignability.

@example
```
import type {Simplify} from 'type-fest';

type PositionProps = {
	top: number;
	left: number;
};

type SizeProps = {
	width: number;
	height: number;
};

// In your editor, hovering over `Props` will show a flattened object with all the properties.
type Props = Simplify<PositionProps & SizeProps>;
```

Sometimes it is desired to pass a value as a function argument that has a different type. At first inspection it may seem assignable, and then you discover it is not because the `value`'s type definition was defined as an interface. In the following example, `fn` requires an argument of type `Record<string, unknown>`. If the value is defined as a literal, then it is assignable. And if the `value` is defined as type using the `Simplify` utility the value is assignable.  But if the `value` is defined as an interface, it is not assignable because the interface is not sealed and elsewhere a non-string property could be added to the interface.

If the type definition must be an interface (perhaps it was defined in a third-party npm package), then the `value` can be defined as `const value: Simplify<SomeInterface> = ...`. Then `value` will be assignable to the `fn` argument.  Or the `value` can be cast as `Simplify<SomeInterface>` if you can't re-declare the `value`.

@example
```
import type {Simplify} from 'type-fest';

interface SomeInterface {
	foo: number;
	bar?: string;
	baz: number | undefined;
}

type SomeType = {
	foo: number;
	bar?: string;
	baz: number | undefined;
};

const literal = {foo: 123, bar: 'hello', baz: 456};
const someType: SomeType = literal;
const someInterface: SomeInterface = literal;

function fn(object: Record<string, unknown>): void {}

fn(literal); // Good: literal object type is sealed
fn(someType); // Good: type is sealed
fn(someInterface); // Error: Index signature for type 'string' is missing in type 'someInterface'. Because `interface` can be re-opened
fn(someInterface as Simplify<SomeInterface>); // Good: transform an `interface` into a `type`
```

@link https://github.com/microsoft/TypeScript/issues/15300
@see SimplifyDeep
@category Object
*/
type Simplify<T> = {[KeyType in keyof T]: T[KeyType]} & {};

/**
Omit any index signatures from the given object type, leaving only explicitly defined properties.

This is the counterpart of `PickIndexSignature`.

Use-cases:
- Remove overly permissive signatures from third-party types.

This type was taken from this [StackOverflow answer](https://stackoverflow.com/a/68261113/420747).

It relies on the fact that an empty object (`{}`) is assignable to an object with just an index signature, like `Record<string, unknown>`, but not to an object with explicitly defined keys, like `Record<'foo' | 'bar', unknown>`.

(The actual value type, `unknown`, is irrelevant and could be any type. Only the key type matters.)

```
const indexed: Record<string, unknown> = {}; // Allowed

const keyed: Record<'foo', unknown> = {}; // Error
// => TS2739: Type '{}' is missing the following properties from type 'Record<"foo" | "bar", unknown>': foo, bar
```

Instead of causing a type error like the above, you can also use a [conditional type](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html) to test whether a type is assignable to another:

```
type Indexed = {} extends Record<string, unknown>
	? '✅ `{}` is assignable to `Record<string, unknown>`'
	: '❌ `{}` is NOT assignable to `Record<string, unknown>`';
// => '✅ `{}` is assignable to `Record<string, unknown>`'

type Keyed = {} extends Record<'foo' | 'bar', unknown>
	? "✅ `{}` is assignable to `Record<'foo' | 'bar', unknown>`"
	: "❌ `{}` is NOT assignable to `Record<'foo' | 'bar', unknown>`";
// => "❌ `{}` is NOT assignable to `Record<'foo' | 'bar', unknown>`"
```

Using a [mapped type](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html#further-exploration), you can then check for each `KeyType` of `ObjectType`...

```
import type {OmitIndexSignature} from 'type-fest';

type OmitIndexSignature<ObjectType> = {
	[KeyType in keyof ObjectType // Map each key of `ObjectType`...
	]: ObjectType[KeyType]; // ...to its original value, i.e. `OmitIndexSignature<Foo> == Foo`.
};
```

...whether an empty object (`{}`) would be assignable to an object with that `KeyType` (`Record<KeyType, unknown>`)...

```
import type {OmitIndexSignature} from 'type-fest';

type OmitIndexSignature<ObjectType> = {
	[KeyType in keyof ObjectType
		// Is `{}` assignable to `Record<KeyType, unknown>`?
		as {} extends Record<KeyType, unknown>
			? ... // ✅ `{}` is assignable to `Record<KeyType, unknown>`
			: ... // ❌ `{}` is NOT assignable to `Record<KeyType, unknown>`
	]: ObjectType[KeyType];
};
```

If `{}` is assignable, it means that `KeyType` is an index signature and we want to remove it. If it is not assignable, `KeyType` is a "real" key and we want to keep it.

@example
```
import type {OmitIndexSignature} from 'type-fest';

interface Example {
	// These index signatures will be removed.
	[x: string]: any
	[x: number]: any
	[x: symbol]: any
	[x: `head-${string}`]: string
	[x: `${string}-tail`]: string
	[x: `head-${string}-tail`]: string
	[x: `${bigint}`]: string
	[x: `embedded-${number}`]: string

	// These explicitly defined keys will remain.
	foo: 'bar';
	qux?: 'baz';
}

type ExampleWithoutIndexSignatures = OmitIndexSignature<Example>;
// => { foo: 'bar'; qux?: 'baz' | undefined; }
```

@see PickIndexSignature
@category Object
*/
type OmitIndexSignature<ObjectType> = {
	[KeyType in keyof ObjectType as {} extends Record<KeyType, unknown>
		? never
		: KeyType]: ObjectType[KeyType];
};

/**
Pick only index signatures from the given object type, leaving out all explicitly defined properties.

This is the counterpart of `OmitIndexSignature`.

@example
```
import type {PickIndexSignature} from 'type-fest';

declare const symbolKey: unique symbol;

type Example = {
	// These index signatures will remain.
	[x: string]: unknown;
	[x: number]: unknown;
	[x: symbol]: unknown;
	[x: `head-${string}`]: string;
	[x: `${string}-tail`]: string;
	[x: `head-${string}-tail`]: string;
	[x: `${bigint}`]: string;
	[x: `embedded-${number}`]: string;

	// These explicitly defined keys will be removed.
	['kebab-case-key']: string;
	[symbolKey]: string;
	foo: 'bar';
	qux?: 'baz';
};

type ExampleIndexSignature = PickIndexSignature<Example>;
// {
// 	[x: string]: unknown;
// 	[x: number]: unknown;
// 	[x: symbol]: unknown;
// 	[x: `head-${string}`]: string;
// 	[x: `${string}-tail`]: string;
// 	[x: `head-${string}-tail`]: string;
// 	[x: `${bigint}`]: string;
// 	[x: `embedded-${number}`]: string;
// }
```

@see OmitIndexSignature
@category Object
*/
type PickIndexSignature<ObjectType> = {
	[KeyType in keyof ObjectType as {} extends Record<KeyType, unknown>
		? KeyType
		: never]: ObjectType[KeyType];
};

// Merges two objects without worrying about index signatures.
type SimpleMerge<Destination, Source> = {
	[Key in keyof Destination as Key extends keyof Source ? never : Key]: Destination[Key];
} & Source;

/**
Merge two types into a new type. Keys of the second type overrides keys of the first type.

@example
```
import type {Merge} from 'type-fest';

interface Foo {
	[x: string]: unknown;
	[x: number]: unknown;
	foo: string;
	bar: symbol;
}

type Bar = {
	[x: number]: number;
	[x: symbol]: unknown;
	bar: Date;
	baz: boolean;
};

export type FooBar = Merge<Foo, Bar>;
// => {
// 	[x: string]: unknown;
// 	[x: number]: number;
// 	[x: symbol]: unknown;
// 	foo: string;
// 	bar: Date;
// 	baz: boolean;
// }
```

@category Object
*/
type Merge<Destination, Source> =
Simplify<
SimpleMerge<PickIndexSignature<Destination>, PickIndexSignature<Source>>
& SimpleMerge<OmitIndexSignature<Destination>, OmitIndexSignature<Source>>
>;

/**
An if-else-like type that resolves depending on whether the given type is `any`.

@see {@link IsAny}

@example
```
import type {IfAny} from 'type-fest';

type ShouldBeTrue = IfAny<any>;
//=> true

type ShouldBeBar = IfAny<'not any', 'foo', 'bar'>;
//=> 'bar'
```

@category Type Guard
@category Utilities
*/
type IfAny<T, TypeIfAny = true, TypeIfNotAny = false> = (
	IsAny<T> extends true ? TypeIfAny : TypeIfNotAny
);

/**
Matches any primitive, `void`, `Date`, or `RegExp` value.
*/
type BuiltIns = Primitive | void | Date | RegExp;

/**
Merges user specified options with default options.

@example
```
type PathsOptions = {maxRecursionDepth?: number; leavesOnly?: boolean};
type DefaultPathsOptions = {maxRecursionDepth: 10; leavesOnly: false};
type SpecifiedOptions = {leavesOnly: true};

type Result = ApplyDefaultOptions<PathsOptions, DefaultPathsOptions, SpecifiedOptions>;
//=> {maxRecursionDepth: 10; leavesOnly: true}
```

@example
```
// Complains if default values are not provided for optional options

type PathsOptions = {maxRecursionDepth?: number; leavesOnly?: boolean};
type DefaultPathsOptions = {maxRecursionDepth: 10};
type SpecifiedOptions = {};

type Result = ApplyDefaultOptions<PathsOptions, DefaultPathsOptions, SpecifiedOptions>;
//                                              ~~~~~~~~~~~~~~~~~~~
// Property 'leavesOnly' is missing in type 'DefaultPathsOptions' but required in type '{ maxRecursionDepth: number; leavesOnly: boolean; }'.
```

@example
```
// Complains if an option's default type does not conform to the expected type

type PathsOptions = {maxRecursionDepth?: number; leavesOnly?: boolean};
type DefaultPathsOptions = {maxRecursionDepth: 10; leavesOnly: 'no'};
type SpecifiedOptions = {};

type Result = ApplyDefaultOptions<PathsOptions, DefaultPathsOptions, SpecifiedOptions>;
//                                              ~~~~~~~~~~~~~~~~~~~
// Types of property 'leavesOnly' are incompatible. Type 'string' is not assignable to type 'boolean'.
```

@example
```
// Complains if an option's specified type does not conform to the expected type

type PathsOptions = {maxRecursionDepth?: number; leavesOnly?: boolean};
type DefaultPathsOptions = {maxRecursionDepth: 10; leavesOnly: false};
type SpecifiedOptions = {leavesOnly: 'yes'};

type Result = ApplyDefaultOptions<PathsOptions, DefaultPathsOptions, SpecifiedOptions>;
//                                                                   ~~~~~~~~~~~~~~~~
// Types of property 'leavesOnly' are incompatible. Type 'string' is not assignable to type 'boolean'.
```
*/
type ApplyDefaultOptions<
	Options extends object,
	Defaults extends Simplify<Omit<Required<Options>, RequiredKeysOf<Options>> & Partial<Record<RequiredKeysOf<Options>, never>>>,
	SpecifiedOptions extends Options,
> =
	IfAny<SpecifiedOptions, Defaults,
	IfNever<SpecifiedOptions, Defaults,
	Simplify<Merge<Defaults, {
		[Key in keyof SpecifiedOptions
		as Key extends OptionalKeysOf<Options>
			? Extract<SpecifiedOptions[Key], undefined> extends never
				? Key
				: never
			: Key
		]: SpecifiedOptions[Key]
	}> & Required<Options>> // `& Required<Options>` ensures that `ApplyDefaultOptions<SomeOption, ...>` is always assignable to `Required<SomeOption>`
	>>;

/**
@see {@link PartialDeep}
*/
type PartialDeepOptions = {
	/**
	Whether to affect the individual elements of arrays and tuples.

	@default false
	*/
	readonly recurseIntoArrays?: boolean;

	/**
	Allows `undefined` values in non-tuple arrays.

	- When set to `true`, elements of non-tuple arrays can be `undefined`.
	- When set to `false`, only explicitly defined elements are allowed in non-tuple arrays, ensuring stricter type checking.

	@default true

	@example
	You can prevent `undefined` values in non-tuple arrays by passing `{recurseIntoArrays: true; allowUndefinedInNonTupleArrays: false}` as the second type argument:

	```
	import type {PartialDeep} from 'type-fest';

	type Settings = {
		languages: string[];
	};

	declare const partialSettings: PartialDeep<Settings, {recurseIntoArrays: true; allowUndefinedInNonTupleArrays: false}>;

	partialSettings.languages = [undefined]; // Error
	partialSettings.languages = []; // Ok
	```
	*/
	readonly allowUndefinedInNonTupleArrays?: boolean;
};

type DefaultPartialDeepOptions = {
	recurseIntoArrays: false;
	allowUndefinedInNonTupleArrays: true;
};

/**
Create a type from another type with all keys and nested keys set to optional.

Use-cases:
- Merging a default settings/config object with another object, the second object would be a deep partial of the default object.
- Mocking and testing complex entities, where populating an entire object with its keys would be redundant in terms of the mock or test.

@example
```
import type {PartialDeep} from 'type-fest';

const settings: Settings = {
	textEditor: {
		fontSize: 14,
		fontColor: '#000000',
		fontWeight: 400
	},
	autocomplete: false,
	autosave: true
};

const applySavedSettings = (savedSettings: PartialDeep<Settings>) => {
	return {...settings, ...savedSettings};
}

settings = applySavedSettings({textEditor: {fontWeight: 500}});
```

By default, this does not affect elements in array and tuple types. You can change this by passing `{recurseIntoArrays: true}` as the second type argument:

```
import type {PartialDeep} from 'type-fest';

type Settings = {
	languages: string[];
}

const partialSettings: PartialDeep<Settings, {recurseIntoArrays: true}> = {
	languages: [undefined]
};
```

@see {@link PartialDeepOptions}

@category Object
@category Array
@category Set
@category Map
*/
type PartialDeep<T, Options extends PartialDeepOptions = {}> =
	_PartialDeep<T, ApplyDefaultOptions<PartialDeepOptions, DefaultPartialDeepOptions, Options>>;

type _PartialDeep<T, Options extends Required<PartialDeepOptions>> = T extends BuiltIns | ((new (...arguments_: any[]) => unknown))
	? T
	: IsNever<keyof T> extends true // For functions with no properties
		? T
		: T extends Map<infer KeyType, infer ValueType>
			? PartialMapDeep<KeyType, ValueType, Options>
			: T extends Set<infer ItemType>
				? PartialSetDeep<ItemType, Options>
				: T extends ReadonlyMap<infer KeyType, infer ValueType>
					? PartialReadonlyMapDeep<KeyType, ValueType, Options>
					: T extends ReadonlySet<infer ItemType>
						? PartialReadonlySetDeep<ItemType, Options>
						: T extends object
							? T extends ReadonlyArray<infer ItemType> // Test for arrays/tuples, per https://github.com/microsoft/TypeScript/issues/35156
								? Options['recurseIntoArrays'] extends true
									? ItemType[] extends T // Test for arrays (non-tuples) specifically
										? readonly ItemType[] extends T // Differentiate readonly and mutable arrays
											? ReadonlyArray<_PartialDeep<Options['allowUndefinedInNonTupleArrays'] extends false ? ItemType : ItemType | undefined, Options>>
											: Array<_PartialDeep<Options['allowUndefinedInNonTupleArrays'] extends false ? ItemType : ItemType | undefined, Options>>
										: PartialObjectDeep<T, Options> // Tuples behave properly
									: T // If they don't opt into array testing, just use the original type
								: PartialObjectDeep<T, Options>
							: unknown;

/**
Same as `PartialDeep`, but accepts only `Map`s and as inputs. Internal helper for `PartialDeep`.
*/
type PartialMapDeep<KeyType, ValueType, Options extends Required<PartialDeepOptions>> = {} & Map<_PartialDeep<KeyType, Options>, _PartialDeep<ValueType, Options>>;

/**
Same as `PartialDeep`, but accepts only `Set`s as inputs. Internal helper for `PartialDeep`.
*/
type PartialSetDeep<T, Options extends Required<PartialDeepOptions>> = {} & Set<_PartialDeep<T, Options>>;

/**
Same as `PartialDeep`, but accepts only `ReadonlyMap`s as inputs. Internal helper for `PartialDeep`.
*/
type PartialReadonlyMapDeep<KeyType, ValueType, Options extends Required<PartialDeepOptions>> = {} & ReadonlyMap<_PartialDeep<KeyType, Options>, _PartialDeep<ValueType, Options>>;

/**
Same as `PartialDeep`, but accepts only `ReadonlySet`s as inputs. Internal helper for `PartialDeep`.
*/
type PartialReadonlySetDeep<T, Options extends Required<PartialDeepOptions>> = {} & ReadonlySet<_PartialDeep<T, Options>>;

/**
Same as `PartialDeep`, but accepts only `object`s as inputs. Internal helper for `PartialDeep`.
*/
type PartialObjectDeep<ObjectType extends object, Options extends Required<PartialDeepOptions>> =
	(ObjectType extends (...arguments_: any) => unknown
		? (...arguments_: Parameters<ObjectType>) => ReturnType<ObjectType>
		: {}) & ({
		[KeyType in keyof ObjectType]?: _PartialDeep<ObjectType[KeyType], Options>
	});

declare const CustomComponentPropSchema: z.ZodMiniObject<{
    /**
     * The name of the prop in the user-defined component.
     * @example
     * "to"
     */
    name: z.ZodMiniString<string>;
    /**
     * The name of the prop in the host component.
     * @example
     * "href"
     */
    as: z.ZodMiniOptional<z.ZodMiniString<string>>;
    /**
     * Whether the prop is controlled or not in the user-defined component.
     * @internal
     * @example
     * `true`
     */
    controlled: z.ZodMiniOptional<z.ZodMiniBoolean<boolean>>;
    /**
     * The default value of the prop in the user-defined component.
     * @example
     * `"/"`
     */
    defaultValue: z.ZodMiniOptional<z.ZodMiniString<string>>;
}, {}>;
/**
 * @description
 * This will provide some key information to the rule before checking for user-defined components.
 * For example:
 * Which prop is used as the `href` prop for the user-defined `Link` component that represents the built-in `a` element.
 */
declare const CustomComponentSchema: z.ZodMiniObject<{
    /**
     * The name of the user-defined component.
     * @example
     * "Link"
     */
    name: z.ZodMiniString<string>;
    /**
     * The name of the host component that the user-defined component represents.
     * @example
     * "a"
     */
    as: z.ZodMiniOptional<z.ZodMiniString<string>>;
    /**
     * Attributes mapping between the user-defined component and the host component.
     * @example
     * `Link` component has a `to` attribute that represents the `href` attribute in the built-in `a` element with a default value of `"/"`.
     */
    attributes: z.ZodMiniOptional<z.ZodMiniArray<z.ZodMiniObject<{
        /**
         * The name of the prop in the user-defined component.
         * @example
         * "to"
         */
        name: z.ZodMiniString<string>;
        /**
         * The name of the prop in the host component.
         * @example
         * "href"
         */
        as: z.ZodMiniOptional<z.ZodMiniString<string>>;
        /**
         * Whether the prop is controlled or not in the user-defined component.
         * @internal
         * @example
         * `true`
         */
        controlled: z.ZodMiniOptional<z.ZodMiniBoolean<boolean>>;
        /**
         * The default value of the prop in the user-defined component.
         * @example
         * `"/"`
         */
        defaultValue: z.ZodMiniOptional<z.ZodMiniString<string>>;
    }, {}>>>;
    /**
     * The ESQuery selector to select the component precisely.
     * @internal
     * @example
     * `JSXElement:has(JSXAttribute[name.name='component'][value.value='a'])`
     */
    selector: z.ZodMiniOptional<z.ZodMiniString<string>>;
}, {}>;
declare const CustomHooksSchema: z.ZodMiniObject<{
    use: z.ZodMiniOptional<z.ZodMiniArray<z.ZodMiniString<string>>>;
    useActionState: z.ZodMiniOptional<z.ZodMiniArray<z.ZodMiniString<string>>>;
    useCallback: z.ZodMiniOptional<z.ZodMiniArray<z.ZodMiniString<string>>>;
    useContext: z.ZodMiniOptional<z.ZodMiniArray<z.ZodMiniString<string>>>;
    useDebugValue: z.ZodMiniOptional<z.ZodMiniArray<z.ZodMiniString<string>>>;
    useDeferredValue: z.ZodMiniOptional<z.ZodMiniArray<z.ZodMiniString<string>>>;
    useEffect: z.ZodMiniOptional<z.ZodMiniArray<z.ZodMiniString<string>>>;
    useFormStatus: z.ZodMiniOptional<z.ZodMiniArray<z.ZodMiniString<string>>>;
    useId: z.ZodMiniOptional<z.ZodMiniArray<z.ZodMiniString<string>>>;
    useImperativeHandle: z.ZodMiniOptional<z.ZodMiniArray<z.ZodMiniString<string>>>;
    useInsertionEffect: z.ZodMiniOptional<z.ZodMiniArray<z.ZodMiniString<string>>>;
    useLayoutEffect: z.ZodMiniOptional<z.ZodMiniArray<z.ZodMiniString<string>>>;
    useMemo: z.ZodMiniOptional<z.ZodMiniArray<z.ZodMiniString<string>>>;
    useOptimistic: z.ZodMiniOptional<z.ZodMiniArray<z.ZodMiniString<string>>>;
    useReducer: z.ZodMiniOptional<z.ZodMiniArray<z.ZodMiniString<string>>>;
    useRef: z.ZodMiniOptional<z.ZodMiniArray<z.ZodMiniString<string>>>;
    useState: z.ZodMiniOptional<z.ZodMiniArray<z.ZodMiniString<string>>>;
    useSyncExternalStore: z.ZodMiniOptional<z.ZodMiniArray<z.ZodMiniString<string>>>;
    useTransition: z.ZodMiniOptional<z.ZodMiniArray<z.ZodMiniString<string>>>;
}, {}>;
/**
 * @internal
 */
declare const ESLintReactSettingsSchema: z.ZodMiniObject<{
    /**
     * The source where React is imported from.
     * @description This allows to specify a custom import location for React when not using the official distribution.
     * @default `"react"`
     * @example `"@pika/react"`
     */
    importSource: z.ZodMiniOptional<z.ZodMiniString<string>>;
    /**
     * The identifier that's used for JSX Element creation.
     * @default `"createElement"`
     * @deprecated
     */
    jsxPragma: z.ZodMiniOptional<z.ZodMiniString<string>>;
    /**
     * The identifier that's used for JSX fragment elements.
     * @description This should not be a member expression (i.e. use "Fragment" instead of "React.Fragment").
     * @default `"Fragment"`
     * @deprecated
     */
    jsxPragmaFrag: z.ZodMiniOptional<z.ZodMiniString<string>>;
    /**
     * The name of the prop that is used for polymorphic components.
     * @description This is used to determine the type of the component.
     * @example `"as"`
     */
    polymorphicPropName: z.ZodMiniOptional<z.ZodMiniString<string>>;
    /**
     * @default `true`
     * @internal
     */
    strict: z.ZodMiniOptional<z.ZodMiniBoolean<boolean>>;
    /**
     * Check both the shape and the import to determine if an API is from React.
     * @default `true`
     * @internal
     */
    skipImportCheck: z.ZodMiniOptional<z.ZodMiniBoolean<boolean>>;
    /**
     * React version to use, "detect" means auto detect React version from the project's dependencies.
     * If `importSource` is specified, an equivalent version of React should be provided here.
     * @example `"18.3.1"`
     * @default `"detect"`
     */
    version: z.ZodMiniOptional<z.ZodMiniString<string>>;
    /**
     * A object to define additional hooks that are equivalent to the built-in React Hooks.
     * @description ESLint React will recognize these aliases as equivalent to the built-in hooks in all its rules.
     * @example `{ useEffect: ["useIsomorphicLayoutEffect"] }`
     */
    additionalHooks: z.ZodMiniOptional<z.ZodMiniObject<{
        use: z.ZodMiniOptional<z.ZodMiniArray<z.ZodMiniString<string>>>;
        useActionState: z.ZodMiniOptional<z.ZodMiniArray<z.ZodMiniString<string>>>;
        useCallback: z.ZodMiniOptional<z.ZodMiniArray<z.ZodMiniString<string>>>;
        useContext: z.ZodMiniOptional<z.ZodMiniArray<z.ZodMiniString<string>>>;
        useDebugValue: z.ZodMiniOptional<z.ZodMiniArray<z.ZodMiniString<string>>>;
        useDeferredValue: z.ZodMiniOptional<z.ZodMiniArray<z.ZodMiniString<string>>>;
        useEffect: z.ZodMiniOptional<z.ZodMiniArray<z.ZodMiniString<string>>>;
        useFormStatus: z.ZodMiniOptional<z.ZodMiniArray<z.ZodMiniString<string>>>;
        useId: z.ZodMiniOptional<z.ZodMiniArray<z.ZodMiniString<string>>>;
        useImperativeHandle: z.ZodMiniOptional<z.ZodMiniArray<z.ZodMiniString<string>>>;
        useInsertionEffect: z.ZodMiniOptional<z.ZodMiniArray<z.ZodMiniString<string>>>;
        useLayoutEffect: z.ZodMiniOptional<z.ZodMiniArray<z.ZodMiniString<string>>>;
        useMemo: z.ZodMiniOptional<z.ZodMiniArray<z.ZodMiniString<string>>>;
        useOptimistic: z.ZodMiniOptional<z.ZodMiniArray<z.ZodMiniString<string>>>;
        useReducer: z.ZodMiniOptional<z.ZodMiniArray<z.ZodMiniString<string>>>;
        useRef: z.ZodMiniOptional<z.ZodMiniArray<z.ZodMiniString<string>>>;
        useState: z.ZodMiniOptional<z.ZodMiniArray<z.ZodMiniString<string>>>;
        useSyncExternalStore: z.ZodMiniOptional<z.ZodMiniArray<z.ZodMiniString<string>>>;
        useTransition: z.ZodMiniOptional<z.ZodMiniArray<z.ZodMiniString<string>>>;
    }, {}>>;
    /**
     * An array of user-defined components
     * @description This is used to inform the ESLint React plugins how to treat these components during checks.
     * @example `[{ name: "Link", as: "a", attributes: [{ name: "to", as: "href" }, { name: "rel", defaultValue: "noopener noreferrer" }] }]`
     */
    additionalComponents: z.ZodMiniOptional<z.ZodMiniArray<z.ZodMiniObject<{
        /**
         * The name of the user-defined component.
         * @example
         * "Link"
         */
        name: z.ZodMiniString<string>;
        /**
         * The name of the host component that the user-defined component represents.
         * @example
         * "a"
         */
        as: z.ZodMiniOptional<z.ZodMiniString<string>>;
        /**
         * Attributes mapping between the user-defined component and the host component.
         * @example
         * `Link` component has a `to` attribute that represents the `href` attribute in the built-in `a` element with a default value of `"/"`.
         */
        attributes: z.ZodMiniOptional<z.ZodMiniArray<z.ZodMiniObject<{
            /**
             * The name of the prop in the user-defined component.
             * @example
             * "to"
             */
            name: z.ZodMiniString<string>;
            /**
             * The name of the prop in the host component.
             * @example
             * "href"
             */
            as: z.ZodMiniOptional<z.ZodMiniString<string>>;
            /**
             * Whether the prop is controlled or not in the user-defined component.
             * @internal
             * @example
             * `true`
             */
            controlled: z.ZodMiniOptional<z.ZodMiniBoolean<boolean>>;
            /**
             * The default value of the prop in the user-defined component.
             * @example
             * `"/"`
             */
            defaultValue: z.ZodMiniOptional<z.ZodMiniString<string>>;
        }, {}>>>;
        /**
         * The ESQuery selector to select the component precisely.
         * @internal
         * @example
         * `JSXElement:has(JSXAttribute[name.name='component'][value.value='a'])`
         */
        selector: z.ZodMiniOptional<z.ZodMiniString<string>>;
    }, {}>>>;
}, {}>;
/**
 * @internal
 */
declare const ESLintSettingsSchema: z.ZodMiniOptional<z.ZodMiniObject<{
    "react-x": z.ZodMiniOptional<z.ZodMiniUnknown>;
}, {}>>;
type CustomComponent = z.infer<typeof CustomComponentSchema>;
type CustomComponentProp = z.infer<typeof CustomComponentPropSchema>;
type CustomHooks = z.infer<typeof CustomHooksSchema>;
type ESLintSettings = z.infer<typeof ESLintSettingsSchema>;
type ESLintReactSettings = z.infer<typeof ESLintReactSettingsSchema>;
declare function isESLintSettings(settings: unknown): settings is ESLintSettings;
declare function isESLintReactSettings(settings: unknown): settings is ESLintReactSettings;
/**
 * The default ESLint settings for "react-x".
 */
declare const DEFAULT_ESLINT_REACT_SETTINGS: {
    readonly version: "detect";
    readonly importSource: "react";
    readonly strict: true;
    readonly skipImportCheck: true;
    readonly polymorphicPropName: "as";
    readonly additionalComponents: [];
    readonly additionalHooks: {
        readonly useEffect: ["useIsomorphicLayoutEffect"];
        readonly useLayoutEffect: ["useIsomorphicLayoutEffect"];
    };
};
declare const DEFAULT_ESLINT_SETTINGS: {
    readonly "react-x": {
        readonly version: "detect";
        readonly importSource: "react";
        readonly strict: true;
        readonly skipImportCheck: true;
        readonly polymorphicPropName: "as";
        readonly additionalComponents: [];
        readonly additionalHooks: {
            readonly useEffect: ["useIsomorphicLayoutEffect"];
            readonly useLayoutEffect: ["useIsomorphicLayoutEffect"];
        };
    };
};
interface CustomComponentPropNormalized {
    name: string;
    as: string;
    defaultValue?: string | _;
}
interface CustomComponentNormalized {
    name: string;
    as: string;
    attributes: CustomComponentPropNormalized[];
    re: {
        test(s: string): boolean;
    };
}
interface ESLintReactSettingsNormalized {
    additionalHooks: CustomHooks;
    components: CustomComponentNormalized[];
    importSource: string;
    polymorphicPropName: string | _;
    skipImportCheck: boolean;
    strict: boolean;
    version: string;
}
declare const coerceESLintSettings: (settings: unknown) => PartialDeep<ESLintSettings>;
declare const decodeESLintSettings: (settings: unknown) => ESLintSettings;
declare const coerceSettings: (settings: unknown) => PartialDeep<ESLintReactSettings>;
declare const decodeSettings: (settings: unknown) => ESLintReactSettings;
declare const normalizeSettings: ({ additionalComponents, additionalHooks, importSource, polymorphicPropName, skipImportCheck, strict, version, ...rest }: ESLintReactSettings) => {
    readonly components: {
        name: string;
        re: {
            test(s: string): boolean;
        };
        as: string;
        attributes: {
            name: string;
            as: string;
            controlled?: boolean | undefined;
            defaultValue?: string | undefined;
        }[];
        selector?: string | undefined;
    }[];
    readonly additionalHooks: {
        use?: string[] | undefined;
        useActionState?: string[] | undefined;
        useCallback?: string[] | undefined;
        useContext?: string[] | undefined;
        useDebugValue?: string[] | undefined;
        useDeferredValue?: string[] | undefined;
        useEffect?: string[] | undefined;
        useFormStatus?: string[] | undefined;
        useId?: string[] | undefined;
        useImperativeHandle?: string[] | undefined;
        useInsertionEffect?: string[] | undefined;
        useLayoutEffect?: string[] | undefined;
        useMemo?: string[] | undefined;
        useOptimistic?: string[] | undefined;
        useReducer?: string[] | undefined;
        useRef?: string[] | undefined;
        useState?: string[] | undefined;
        useSyncExternalStore?: string[] | undefined;
        useTransition?: string[] | undefined;
    };
    readonly importSource: string;
    readonly polymorphicPropName: string;
    readonly skipImportCheck: boolean;
    readonly strict: boolean;
    readonly version: string;
    readonly jsxPragma?: string | undefined;
    readonly jsxPragmaFrag?: string | undefined;
};
declare function getSettingsFromContext(context: RuleContext): ESLintReactSettingsNormalized;
/**
 * A helper function to define settings for "react-x" with type checking in JavaScript files.
 * @param settings The settings.
 * @returns The settings.
 */
declare const defineSettings: (settings: ESLintReactSettings) => ESLintReactSettings;
declare module "@typescript-eslint/utils/ts-eslint" {
    interface SharedConfigurationSettings {
        ["react-x"]?: Partial<ESLintReactSettings>;
    }
}

export { type CustomComponent, type CustomComponentNormalized, type CustomComponentProp, type CustomComponentPropNormalized, CustomComponentPropSchema, CustomComponentSchema, type CustomHooks, CustomHooksSchema, DEFAULT_ESLINT_REACT_SETTINGS, DEFAULT_ESLINT_SETTINGS, type ESLintReactSettings, type ESLintReactSettingsNormalized, ESLintReactSettingsSchema, type ESLintSettings, ESLintSettingsSchema, GITHUB_URL, NPM_SCOPE, WEBSITE_URL, coerceESLintSettings, coerceSettings, decodeESLintSettings, decodeSettings, defineSettings, getDocsUrl, getId, getReactVersion, getSettingsFromContext, isESLintReactSettings, isESLintSettings, normalizeSettings };
