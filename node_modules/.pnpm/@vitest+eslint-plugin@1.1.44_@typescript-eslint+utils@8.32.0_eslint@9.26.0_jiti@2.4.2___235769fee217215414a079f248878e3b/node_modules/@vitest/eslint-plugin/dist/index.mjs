import{ESLintUtils as re,AST_NODE_TYPES as r,AST_TOKEN_TYPES as bt}from"@typescript-eslint/utils";import W from"typescript";import{isAbsolute as Es,posix as Ts}from"node:path";import{createRequire as xt}from"node:module";const ws="1.1.44";function m(e){return re.RuleCreator(s=>`https://github.com/vitest-dev/eslint-plugin-vitest/blob/main/docs/rules/${s}.md`)(e)}const As=(e,s)=>e&&s?`${e}.${s}`:null,M=e=>e.type===r.FunctionExpression||e.type===r.ArrowFunctionExpression;function R(e){if(v(e))return y(e);switch(e.type){case r.TaggedTemplateExpression:return R(e.tag);case r.MemberExpression:return As(R(e.object),R(e.property));case r.NewExpression:case r.CallExpression:return R(e.callee)}return null}const v=(e,s)=>F(e,s)||L(e,s),F=(e,s)=>e.type===r.Identifier&&(s===void 0||e.name===s),Cs=(e,s)=>e.type===r.TemplateLiteral&&e.quasis.length===1&&(s===void 0||e.quasis[0].value.raw===s),vs=(e,s)=>e.type===r.Literal&&typeof e.value=="string"&&(s===void 0||e.value===s),L=(e,s)=>vs(e,s)||Cs(e,s),y=e=>e.type===r.Identifier?e.name:U(e),U=e=>e?.type===r.TemplateLiteral?e.quasis[0].value.raw:e?.value,K=(e,s,t)=>e.replaceText(s,s.type===r.Identifier?t:`'${t}'`),It=(e,s,t,n)=>{const o=t.arguments[n],i=t.arguments[t.arguments.length-1],{sourceCode:a}=s;let c=a.getTokenAfter(i);return c.value===","&&(c=a.getTokenAfter(c)),e.removeRange([o.range[0],c.range[0]])},Ss=(e,s)=>y(e.matcher)==="toBeInstanceOf"&&e.args.length===1&&v(e.args[0],s);var D=(e=>(e.describe="describe",e.fdescribe="fdescribe",e.xdescribe="xdescribe",e))(D||{}),q=(e=>(e.fit="fit",e.it="it",e.test="test",e.xit="xit",e.xtest="xtest",e.bench="bench",e))(q||{}),qt=(e=>(e.beforeAll="beforeAll",e.beforeEach="beforeEach",e.afterAll="afterAll",e.afterEach="afterEach",e))(qt||{}),N=(e=>(e.to="to",e.have="have",e.not="not",e.rejects="rejects",e.resolves="resolves",e.returns="returns",e.branded="branded",e.asserts="asserts",e.constructorParameters="constructorParameters",e.parameters="parameters",e.thisParameter="thisParameter",e.guards="guards",e.instance="instance",e.items="items",e))(N||{}),B=(e=>(e.toBe="toBe",e.toEqual="toEqual",e.toStrictEqual="toStrictEqual",e))(B||{});function Et(e){return e.getSymbol()?.getDeclarations()?.some(s=>W.isArrowFunction(s)||W.isClassDeclaration(s)||W.isClassExpression(s)||W.isFunctionDeclaration(s)||W.isFunctionExpression(s)||W.isMethodDeclaration(s))??!1}const Ms=new Set(["beforeEach","beforeAll","afterEach","afterAll","it","it.skip","it.only","it.concurrent","it.sequential","it.todo","it.fails","it.extend","it.skipIf","it.runIf","it.each","it.skip.only","it.skip.concurrent","it.skip.sequential","it.skip.todo","it.skip.fails","it.only.skip","it.only.concurrent","it.only.sequential","it.only.todo","it.only.fails","it.concurrent.skip","it.concurrent.only","it.concurrent.sequential","it.concurrent.todo","it.concurrent.fails","it.sequential.skip","it.sequential.only","it.sequential.concurrent","it.sequential.todo","it.sequential.fails","it.todo.skip","it.todo.only","it.todo.concurrent","it.todo.sequential","it.todo.fails","it.fails.skip","it.fails.only","it.fails.concurrent","it.fails.sequential","it.fails.todo","it.extend.skip","it.extend.only","it.extend.concurrent","it.extend.sequential","it.extend.todo","it.extend.fails","it.skipIf.skip","it.skipIf.only","it.skipIf.concurrent","it.skipIf.sequential","it.skipIf.todo","it.skipIf.fails","it.runIf.skip","it.runIf.only","it.runIf.concurrent","it.runIf.sequential","it.runIf.todo","it.runIf.fails","it.skip.each","it.only.each","it.concurrent.each","it.sequential.each","it.todo.each","it.fails.each","it.extend.skipIf","it.extend.runIf","it.extend.each","it.skipIf.each","it.runIf.each","it.skip.only.concurrent","it.skip.only.sequential","it.skip.only.todo","it.skip.only.fails","it.skip.concurrent.only","it.skip.concurrent.sequential","it.skip.concurrent.todo","it.skip.concurrent.fails","it.skip.sequential.only","it.skip.sequential.concurrent","it.skip.sequential.todo","it.skip.sequential.fails","it.skip.todo.only","it.skip.todo.concurrent","it.skip.todo.sequential","it.skip.todo.fails","it.skip.fails.only","it.skip.fails.concurrent","it.skip.fails.sequential","it.skip.fails.todo","it.only.skip.concurrent","it.only.skip.sequential","it.only.skip.todo","it.only.skip.fails","it.only.concurrent.skip","it.only.concurrent.sequential","it.only.concurrent.todo","it.only.concurrent.fails","it.only.sequential.skip","it.only.sequential.concurrent","it.only.sequential.todo","it.only.sequential.fails","it.only.todo.skip","it.only.todo.concurrent","it.only.todo.sequential","it.only.todo.fails","it.only.fails.skip","it.only.fails.concurrent","it.only.fails.sequential","it.only.fails.todo","it.concurrent.skip.only","it.concurrent.skip.sequential","it.concurrent.skip.todo","it.concurrent.skip.fails","it.concurrent.only.skip","it.concurrent.only.sequential","it.concurrent.only.todo","it.concurrent.only.fails","it.concurrent.sequential.skip","it.concurrent.sequential.only","it.concurrent.sequential.todo","it.concurrent.sequential.fails","it.concurrent.todo.skip","it.concurrent.todo.only","it.concurrent.todo.sequential","it.concurrent.todo.fails","it.concurrent.fails.skip","it.concurrent.fails.only","it.concurrent.fails.sequential","it.concurrent.fails.todo","it.sequential.skip.only","it.sequential.skip.concurrent","it.sequential.skip.todo","it.sequential.skip.fails","it.sequential.only.skip","it.sequential.only.concurrent","it.sequential.only.todo","it.sequential.only.fails","it.sequential.concurrent.skip","it.sequential.concurrent.only","it.sequential.concurrent.todo","it.sequential.concurrent.fails","it.sequential.todo.skip","it.sequential.todo.only","it.sequential.todo.concurrent","it.sequential.todo.fails","it.sequential.fails.skip","it.sequential.fails.only","it.sequential.fails.concurrent","it.sequential.fails.todo","it.todo.skip.only","it.todo.skip.concurrent","it.todo.skip.sequential","it.todo.skip.fails","it.todo.only.skip","it.todo.only.concurrent","it.todo.only.sequential","it.todo.only.fails","it.todo.concurrent.skip","it.todo.concurrent.only","it.todo.concurrent.sequential","it.todo.concurrent.fails","it.todo.sequential.skip","it.todo.sequential.only","it.todo.sequential.concurrent","it.todo.sequential.fails","it.todo.fails.skip","it.todo.fails.only","it.todo.fails.concurrent","it.todo.fails.sequential","it.fails.skip.only","it.fails.skip.concurrent","it.fails.skip.sequential","it.fails.skip.todo","it.fails.only.skip","it.fails.only.concurrent","it.fails.only.sequential","it.fails.only.todo","it.fails.concurrent.skip","it.fails.concurrent.only","it.fails.concurrent.sequential","it.fails.concurrent.todo","it.fails.sequential.skip","it.fails.sequential.only","it.fails.sequential.concurrent","it.fails.sequential.todo","it.fails.todo.skip","it.fails.todo.only","it.fails.todo.concurrent","it.fails.todo.sequential","it.extend.skip.only","it.extend.skip.concurrent","it.extend.skip.sequential","it.extend.skip.todo","it.extend.skip.fails","it.extend.only.skip","it.extend.only.concurrent","it.extend.only.sequential","it.extend.only.todo","it.extend.only.fails","it.extend.concurrent.skip","it.extend.concurrent.only","it.extend.concurrent.sequential","it.extend.concurrent.todo","it.extend.concurrent.fails","it.extend.sequential.skip","it.extend.sequential.only","it.extend.sequential.concurrent","it.extend.sequential.todo","it.extend.sequential.fails","it.extend.todo.skip","it.extend.todo.only","it.extend.todo.concurrent","it.extend.todo.sequential","it.extend.todo.fails","it.extend.fails.skip","it.extend.fails.only","it.extend.fails.concurrent","it.extend.fails.sequential","it.extend.fails.todo","it.skipIf.skip.only","it.skipIf.skip.concurrent","it.skipIf.skip.sequential","it.skipIf.skip.todo","it.skipIf.skip.fails","it.skipIf.only.skip","it.skipIf.only.concurrent","it.skipIf.only.sequential","it.skipIf.only.todo","it.skipIf.only.fails","it.skipIf.concurrent.skip","it.skipIf.concurrent.only","it.skipIf.concurrent.sequential","it.skipIf.concurrent.todo","it.skipIf.concurrent.fails","it.skipIf.sequential.skip","it.skipIf.sequential.only","it.skipIf.sequential.concurrent","it.skipIf.sequential.todo","it.skipIf.sequential.fails","it.skipIf.todo.skip","it.skipIf.todo.only","it.skipIf.todo.concurrent","it.skipIf.todo.sequential","it.skipIf.todo.fails","it.skipIf.fails.skip","it.skipIf.fails.only","it.skipIf.fails.concurrent","it.skipIf.fails.sequential","it.skipIf.fails.todo","it.runIf.skip.only","it.runIf.skip.concurrent","it.runIf.skip.sequential","it.runIf.skip.todo","it.runIf.skip.fails","it.runIf.only.skip","it.runIf.only.concurrent","it.runIf.only.sequential","it.runIf.only.todo","it.runIf.only.fails","it.runIf.concurrent.skip","it.runIf.concurrent.only","it.runIf.concurrent.sequential","it.runIf.concurrent.todo","it.runIf.concurrent.fails","it.runIf.sequential.skip","it.runIf.sequential.only","it.runIf.sequential.concurrent","it.runIf.sequential.todo","it.runIf.sequential.fails","it.runIf.todo.skip","it.runIf.todo.only","it.runIf.todo.concurrent","it.runIf.todo.sequential","it.runIf.todo.fails","it.runIf.fails.skip","it.runIf.fails.only","it.runIf.fails.concurrent","it.runIf.fails.sequential","it.runIf.fails.todo","it.skip.only.each","it.skip.concurrent.each","it.skip.sequential.each","it.skip.todo.each","it.skip.fails.each","it.only.skip.each","it.only.concurrent.each","it.only.sequential.each","it.only.todo.each","it.only.fails.each","it.concurrent.skip.each","it.concurrent.only.each","it.concurrent.sequential.each","it.concurrent.todo.each","it.concurrent.fails.each","it.sequential.skip.each","it.sequential.only.each","it.sequential.concurrent.each","it.sequential.todo.each","it.sequential.fails.each","it.todo.skip.each","it.todo.only.each","it.todo.concurrent.each","it.todo.sequential.each","it.todo.fails.each","it.fails.skip.each","it.fails.only.each","it.fails.concurrent.each","it.fails.sequential.each","it.fails.todo.each","it.extend.skipIf.skip","it.extend.skipIf.only","it.extend.skipIf.concurrent","it.extend.skipIf.sequential","it.extend.skipIf.todo","it.extend.skipIf.fails","it.extend.runIf.skip","it.extend.runIf.only","it.extend.runIf.concurrent","it.extend.runIf.sequential","it.extend.runIf.todo","it.extend.runIf.fails","it.extend.skip.each","it.extend.only.each","it.extend.concurrent.each","it.extend.sequential.each","it.extend.todo.each","it.extend.fails.each","it.skipIf.skip.each","it.skipIf.only.each","it.skipIf.concurrent.each","it.skipIf.sequential.each","it.skipIf.todo.each","it.skipIf.fails.each","it.runIf.skip.each","it.runIf.only.each","it.runIf.concurrent.each","it.runIf.sequential.each","it.runIf.todo.each","it.runIf.fails.each","it.extend.skipIf.each","it.extend.runIf.each","test","test.skip","test.only","test.concurrent","test.sequential","test.todo","test.fails","test.extend","test.skipIf","test.runIf","test.each","test.skip.only","test.skip.concurrent","test.skip.sequential","test.skip.todo","test.skip.fails","test.only.skip","test.only.concurrent","test.only.sequential","test.only.todo","test.only.fails","test.concurrent.skip","test.concurrent.only","test.concurrent.sequential","test.concurrent.todo","test.concurrent.fails","test.sequential.skip","test.sequential.only","test.sequential.concurrent","test.sequential.todo","test.sequential.fails","test.todo.skip","test.todo.only","test.todo.concurrent","test.todo.sequential","test.todo.fails","test.fails.skip","test.fails.only","test.fails.concurrent","test.fails.sequential","test.fails.todo","test.extend.skip","test.extend.only","test.extend.concurrent","test.extend.sequential","test.extend.todo","test.extend.fails","test.skipIf.skip","test.skipIf.only","test.skipIf.concurrent","test.skipIf.sequential","test.skipIf.todo","test.skipIf.fails","test.runIf.skip","test.runIf.only","test.runIf.concurrent","test.runIf.sequential","test.runIf.todo","test.runIf.fails","test.skip.each","test.only.each","test.concurrent.each","test.sequential.each","test.todo.each","test.fails.each","test.extend.skipIf","test.extend.runIf","test.extend.each","test.skipIf.each","test.runIf.each","test.skip.only.concurrent","test.skip.only.sequential","test.skip.only.todo","test.skip.only.fails","test.skip.concurrent.only","test.skip.concurrent.sequential","test.skip.concurrent.todo","test.skip.concurrent.fails","test.skip.sequential.only","test.skip.sequential.concurrent","test.skip.sequential.todo","test.skip.sequential.fails","test.skip.todo.only","test.skip.todo.concurrent","test.skip.todo.sequential","test.skip.todo.fails","test.skip.fails.only","test.skip.fails.concurrent","test.skip.fails.sequential","test.skip.fails.todo","test.only.skip.concurrent","test.only.skip.sequential","test.only.skip.todo","test.only.skip.fails","test.only.concurrent.skip","test.only.concurrent.sequential","test.only.concurrent.todo","test.only.concurrent.fails","test.only.sequential.skip","test.only.sequential.concurrent","test.only.sequential.todo","test.only.sequential.fails","test.only.todo.skip","test.only.todo.concurrent","test.only.todo.sequential","test.only.todo.fails","test.only.fails.skip","test.only.fails.concurrent","test.only.fails.sequential","test.only.fails.todo","test.concurrent.skip.only","test.concurrent.skip.sequential","test.concurrent.skip.todo","test.concurrent.skip.fails","test.concurrent.only.skip","test.concurrent.only.sequential","test.concurrent.only.todo","test.concurrent.only.fails","test.concurrent.sequential.skip","test.concurrent.sequential.only","test.concurrent.sequential.todo","test.concurrent.sequential.fails","test.concurrent.todo.skip","test.concurrent.todo.only","test.concurrent.todo.sequential","test.concurrent.todo.fails","test.concurrent.fails.skip","test.concurrent.fails.only","test.concurrent.fails.sequential","test.concurrent.fails.todo","test.sequential.skip.only","test.sequential.skip.concurrent","test.sequential.skip.todo","test.sequential.skip.fails","test.sequential.only.skip","test.sequential.only.concurrent","test.sequential.only.todo","test.sequential.only.fails","test.sequential.concurrent.skip","test.sequential.concurrent.only","test.sequential.concurrent.todo","test.sequential.concurrent.fails","test.sequential.todo.skip","test.sequential.todo.only","test.sequential.todo.concurrent","test.sequential.todo.fails","test.sequential.fails.skip","test.sequential.fails.only","test.sequential.fails.concurrent","test.sequential.fails.todo","test.todo.skip.only","test.todo.skip.concurrent","test.todo.skip.sequential","test.todo.skip.fails","test.todo.only.skip","test.todo.only.concurrent","test.todo.only.sequential","test.todo.only.fails","test.todo.concurrent.skip","test.todo.concurrent.only","test.todo.concurrent.sequential","test.todo.concurrent.fails","test.todo.sequential.skip","test.todo.sequential.only","test.todo.sequential.concurrent","test.todo.sequential.fails","test.todo.fails.skip","test.todo.fails.only","test.todo.fails.concurrent","test.todo.fails.sequential","test.fails.skip.only","test.fails.skip.concurrent","test.fails.skip.sequential","test.fails.skip.todo","test.fails.only.skip","test.fails.only.concurrent","test.fails.only.sequential","test.fails.only.todo","test.fails.concurrent.skip","test.fails.concurrent.only","test.fails.concurrent.sequential","test.fails.concurrent.todo","test.fails.sequential.skip","test.fails.sequential.only","test.fails.sequential.concurrent","test.fails.sequential.todo","test.fails.todo.skip","test.fails.todo.only","test.fails.todo.concurrent","test.fails.todo.sequential","test.extend.skip.only","test.extend.skip.concurrent","test.extend.skip.sequential","test.extend.skip.todo","test.extend.skip.fails","test.extend.only.skip","test.extend.only.concurrent","test.extend.only.sequential","test.extend.only.todo","test.extend.only.fails","test.extend.concurrent.skip","test.extend.concurrent.only","test.extend.concurrent.sequential","test.extend.concurrent.todo","test.extend.concurrent.fails","test.extend.sequential.skip","test.extend.sequential.only","test.extend.sequential.concurrent","test.extend.sequential.todo","test.extend.sequential.fails","test.extend.todo.skip","test.extend.todo.only","test.extend.todo.concurrent","test.extend.todo.sequential","test.extend.todo.fails","test.extend.fails.skip","test.extend.fails.only","test.extend.fails.concurrent","test.extend.fails.sequential","test.extend.fails.todo","test.skipIf.skip.only","test.skipIf.skip.concurrent","test.skipIf.skip.sequential","test.skipIf.skip.todo","test.skipIf.skip.fails","test.skipIf.only.skip","test.skipIf.only.concurrent","test.skipIf.only.sequential","test.skipIf.only.todo","test.skipIf.only.fails","test.skipIf.concurrent.skip","test.skipIf.concurrent.only","test.skipIf.concurrent.sequential","test.skipIf.concurrent.todo","test.skipIf.concurrent.fails","test.skipIf.sequential.skip","test.skipIf.sequential.only","test.skipIf.sequential.concurrent","test.skipIf.sequential.todo","test.skipIf.sequential.fails","test.skipIf.todo.skip","test.skipIf.todo.only","test.skipIf.todo.concurrent","test.skipIf.todo.sequential","test.skipIf.todo.fails","test.skipIf.fails.skip","test.skipIf.fails.only","test.skipIf.fails.concurrent","test.skipIf.fails.sequential","test.skipIf.fails.todo","test.runIf.skip.only","test.runIf.skip.concurrent","test.runIf.skip.sequential","test.runIf.skip.todo","test.runIf.skip.fails","test.runIf.only.skip","test.runIf.only.concurrent","test.runIf.only.sequential","test.runIf.only.todo","test.runIf.only.fails","test.runIf.concurrent.skip","test.runIf.concurrent.only","test.runIf.concurrent.sequential","test.runIf.concurrent.todo","test.runIf.concurrent.fails","test.runIf.sequential.skip","test.runIf.sequential.only","test.runIf.sequential.concurrent","test.runIf.sequential.todo","test.runIf.sequential.fails","test.runIf.todo.skip","test.runIf.todo.only","test.runIf.todo.concurrent","test.runIf.todo.sequential","test.runIf.todo.fails","test.runIf.fails.skip","test.runIf.fails.only","test.runIf.fails.concurrent","test.runIf.fails.sequential","test.runIf.fails.todo","test.skip.only.each","test.skip.concurrent.each","test.skip.sequential.each","test.skip.todo.each","test.skip.fails.each","test.only.skip.each","test.only.concurrent.each","test.only.sequential.each","test.only.todo.each","test.only.fails.each","test.concurrent.skip.each","test.concurrent.only.each","test.concurrent.sequential.each","test.concurrent.todo.each","test.concurrent.fails.each","test.sequential.skip.each","test.sequential.only.each","test.sequential.concurrent.each","test.sequential.todo.each","test.sequential.fails.each","test.todo.skip.each","test.todo.only.each","test.todo.concurrent.each","test.todo.sequential.each","test.todo.fails.each","test.fails.skip.each","test.fails.only.each","test.fails.concurrent.each","test.fails.sequential.each","test.fails.todo.each","test.extend.skipIf.skip","test.extend.skipIf.only","test.extend.skipIf.concurrent","test.extend.skipIf.sequential","test.extend.skipIf.todo","test.extend.skipIf.fails","test.extend.runIf.skip","test.extend.runIf.only","test.extend.runIf.concurrent","test.extend.runIf.sequential","test.extend.runIf.todo","test.extend.runIf.fails","test.extend.skip.each","test.extend.only.each","test.extend.concurrent.each","test.extend.sequential.each","test.extend.todo.each","test.extend.fails.each","test.skipIf.skip.each","test.skipIf.only.each","test.skipIf.concurrent.each","test.skipIf.sequential.each","test.skipIf.todo.each","test.skipIf.fails.each","test.runIf.skip.each","test.runIf.only.each","test.runIf.concurrent.each","test.runIf.sequential.each","test.runIf.todo.each","test.runIf.fails.each","test.extend.skipIf.each","test.extend.runIf.each","bench","bench.skip","bench.only","bench.todo","bench.skipIf","bench.runIf","bench.skip.only","bench.skip.todo","bench.only.skip","bench.only.todo","bench.todo.skip","bench.todo.only","bench.skipIf.skip","bench.skipIf.only","bench.skipIf.todo","bench.runIf.skip","bench.runIf.only","bench.runIf.todo","bench.skip.only.todo","bench.skip.todo.only","bench.only.skip.todo","bench.only.todo.skip","bench.todo.skip.only","bench.todo.only.skip","bench.skipIf.skip.only","bench.skipIf.skip.todo","bench.skipIf.only.skip","bench.skipIf.only.todo","bench.skipIf.todo.skip","bench.skipIf.todo.only","bench.runIf.skip.only","bench.runIf.skip.todo","bench.runIf.only.skip","bench.runIf.only.todo","bench.runIf.todo.skip","bench.runIf.todo.only","describe","describe.skip","describe.only","describe.concurrent","describe.sequential","describe.shuffle","describe.todo","describe.skipIf","describe.runIf","describe.each","describe.skip.only","describe.skip.concurrent","describe.skip.sequential","describe.skip.shuffle","describe.skip.todo","describe.only.skip","describe.only.concurrent","describe.only.sequential","describe.only.shuffle","describe.only.todo","describe.concurrent.skip","describe.concurrent.only","describe.concurrent.sequential","describe.concurrent.shuffle","describe.concurrent.todo","describe.sequential.skip","describe.sequential.only","describe.sequential.concurrent","describe.sequential.shuffle","describe.sequential.todo","describe.shuffle.skip","describe.shuffle.only","describe.shuffle.concurrent","describe.shuffle.sequential","describe.shuffle.todo","describe.todo.skip","describe.todo.only","describe.todo.concurrent","describe.todo.sequential","describe.todo.shuffle","describe.skipIf.skip","describe.skipIf.only","describe.skipIf.concurrent","describe.skipIf.sequential","describe.skipIf.shuffle","describe.skipIf.todo","describe.runIf.skip","describe.runIf.only","describe.runIf.concurrent","describe.runIf.sequential","describe.runIf.shuffle","describe.runIf.todo","describe.skip.each","describe.only.each","describe.concurrent.each","describe.sequential.each","describe.shuffle.each","describe.todo.each","describe.skipIf.each","describe.runIf.each","describe.skip.only.concurrent","describe.skip.only.sequential","describe.skip.only.shuffle","describe.skip.only.todo","describe.skip.concurrent.only","describe.skip.concurrent.sequential","describe.skip.concurrent.shuffle","describe.skip.concurrent.todo","describe.skip.sequential.only","describe.skip.sequential.concurrent","describe.skip.sequential.shuffle","describe.skip.sequential.todo","describe.skip.shuffle.only","describe.skip.shuffle.concurrent","describe.skip.shuffle.sequential","describe.skip.shuffle.todo","describe.skip.todo.only","describe.skip.todo.concurrent","describe.skip.todo.sequential","describe.skip.todo.shuffle","describe.only.skip.concurrent","describe.only.skip.sequential","describe.only.skip.shuffle","describe.only.skip.todo","describe.only.concurrent.skip","describe.only.concurrent.sequential","describe.only.concurrent.shuffle","describe.only.concurrent.todo","describe.only.sequential.skip","describe.only.sequential.concurrent","describe.only.sequential.shuffle","describe.only.sequential.todo","describe.only.shuffle.skip","describe.only.shuffle.concurrent","describe.only.shuffle.sequential","describe.only.shuffle.todo","describe.only.todo.skip","describe.only.todo.concurrent","describe.only.todo.sequential","describe.only.todo.shuffle","describe.concurrent.skip.only","describe.concurrent.skip.sequential","describe.concurrent.skip.shuffle","describe.concurrent.skip.todo","describe.concurrent.only.skip","describe.concurrent.only.sequential","describe.concurrent.only.shuffle","describe.concurrent.only.todo","describe.concurrent.sequential.skip","describe.concurrent.sequential.only","describe.concurrent.sequential.shuffle","describe.concurrent.sequential.todo","describe.concurrent.shuffle.skip","describe.concurrent.shuffle.only","describe.concurrent.shuffle.sequential","describe.concurrent.shuffle.todo","describe.concurrent.todo.skip","describe.concurrent.todo.only","describe.concurrent.todo.sequential","describe.concurrent.todo.shuffle","describe.sequential.skip.only","describe.sequential.skip.concurrent","describe.sequential.skip.shuffle","describe.sequential.skip.todo","describe.sequential.only.skip","describe.sequential.only.concurrent","describe.sequential.only.shuffle","describe.sequential.only.todo","describe.sequential.concurrent.skip","describe.sequential.concurrent.only","describe.sequential.concurrent.shuffle","describe.sequential.concurrent.todo","describe.sequential.shuffle.skip","describe.sequential.shuffle.only","describe.sequential.shuffle.concurrent","describe.sequential.shuffle.todo","describe.sequential.todo.skip","describe.sequential.todo.only","describe.sequential.todo.concurrent","describe.sequential.todo.shuffle","describe.shuffle.skip.only","describe.shuffle.skip.concurrent","describe.shuffle.skip.sequential","describe.shuffle.skip.todo","describe.shuffle.only.skip","describe.shuffle.only.concurrent","describe.shuffle.only.sequential","describe.shuffle.only.todo","describe.shuffle.concurrent.skip","describe.shuffle.concurrent.only","describe.shuffle.concurrent.sequential","describe.shuffle.concurrent.todo","describe.shuffle.sequential.skip","describe.shuffle.sequential.only","describe.shuffle.sequential.concurrent","describe.shuffle.sequential.todo","describe.shuffle.todo.skip","describe.shuffle.todo.only","describe.shuffle.todo.concurrent","describe.shuffle.todo.sequential","describe.todo.skip.only","describe.todo.skip.concurrent","describe.todo.skip.sequential","describe.todo.skip.shuffle","describe.todo.only.skip","describe.todo.only.concurrent","describe.todo.only.sequential","describe.todo.only.shuffle","describe.todo.concurrent.skip","describe.todo.concurrent.only","describe.todo.concurrent.sequential","describe.todo.concurrent.shuffle","describe.todo.sequential.skip","describe.todo.sequential.only","describe.todo.sequential.concurrent","describe.todo.sequential.shuffle","describe.todo.shuffle.skip","describe.todo.shuffle.only","describe.todo.shuffle.concurrent","describe.todo.shuffle.sequential","describe.skipIf.skip.only","describe.skipIf.skip.concurrent","describe.skipIf.skip.sequential","describe.skipIf.skip.shuffle","describe.skipIf.skip.todo","describe.skipIf.only.skip","describe.skipIf.only.concurrent","describe.skipIf.only.sequential","describe.skipIf.only.shuffle","describe.skipIf.only.todo","describe.skipIf.concurrent.skip","describe.skipIf.concurrent.only","describe.skipIf.concurrent.sequential","describe.skipIf.concurrent.shuffle","describe.skipIf.concurrent.todo","describe.skipIf.sequential.skip","describe.skipIf.sequential.only","describe.skipIf.sequential.concurrent","describe.skipIf.sequential.shuffle","describe.skipIf.sequential.todo","describe.skipIf.shuffle.skip","describe.skipIf.shuffle.only","describe.skipIf.shuffle.concurrent","describe.skipIf.shuffle.sequential","describe.skipIf.shuffle.todo","describe.skipIf.todo.skip","describe.skipIf.todo.only","describe.skipIf.todo.concurrent","describe.skipIf.todo.sequential","describe.skipIf.todo.shuffle","describe.runIf.skip.only","describe.runIf.skip.concurrent","describe.runIf.skip.sequential","describe.runIf.skip.shuffle","describe.runIf.skip.todo","describe.runIf.only.skip","describe.runIf.only.concurrent","describe.runIf.only.sequential","describe.runIf.only.shuffle","describe.runIf.only.todo","describe.runIf.concurrent.skip","describe.runIf.concurrent.only","describe.runIf.concurrent.sequential","describe.runIf.concurrent.shuffle","describe.runIf.concurrent.todo","describe.runIf.sequential.skip","describe.runIf.sequential.only","describe.runIf.sequential.concurrent","describe.runIf.sequential.shuffle","describe.runIf.sequential.todo","describe.runIf.shuffle.skip","describe.runIf.shuffle.only","describe.runIf.shuffle.concurrent","describe.runIf.shuffle.sequential","describe.runIf.shuffle.todo","describe.runIf.todo.skip","describe.runIf.todo.only","describe.runIf.todo.concurrent","describe.runIf.todo.sequential","describe.runIf.todo.shuffle","describe.skip.only.each","describe.skip.concurrent.each","describe.skip.sequential.each","describe.skip.shuffle.each","describe.skip.todo.each","describe.only.skip.each","describe.only.concurrent.each","describe.only.sequential.each","describe.only.shuffle.each","describe.only.todo.each","describe.concurrent.skip.each","describe.concurrent.only.each","describe.concurrent.sequential.each","describe.concurrent.shuffle.each","describe.concurrent.todo.each","describe.sequential.skip.each","describe.sequential.only.each","describe.sequential.concurrent.each","describe.sequential.shuffle.each","describe.sequential.todo.each","describe.shuffle.skip.each","describe.shuffle.only.each","describe.shuffle.concurrent.each","describe.shuffle.sequential.each","describe.shuffle.todo.each","describe.todo.skip.each","describe.todo.only.each","describe.todo.concurrent.each","describe.todo.sequential.each","describe.todo.shuffle.each","describe.skipIf.skip.each","describe.skipIf.only.each","describe.skipIf.concurrent.each","describe.skipIf.sequential.each","describe.skipIf.shuffle.each","describe.skipIf.todo.each","describe.runIf.skip.each","describe.runIf.only.each","describe.runIf.concurrent.each","describe.runIf.sequential.each","describe.runIf.shuffle.each","describe.runIf.todo.each","suite","suite.skip","suite.only","suite.concurrent","suite.sequential","suite.shuffle","suite.todo","suite.skipIf","suite.runIf","suite.each","suite.skip.only","suite.skip.concurrent","suite.skip.sequential","suite.skip.shuffle","suite.skip.todo","suite.only.skip","suite.only.concurrent","suite.only.sequential","suite.only.shuffle","suite.only.todo","suite.concurrent.skip","suite.concurrent.only","suite.concurrent.sequential","suite.concurrent.shuffle","suite.concurrent.todo","suite.sequential.skip","suite.sequential.only","suite.sequential.concurrent","suite.sequential.shuffle","suite.sequential.todo","suite.shuffle.skip","suite.shuffle.only","suite.shuffle.concurrent","suite.shuffle.sequential","suite.shuffle.todo","suite.todo.skip","suite.todo.only","suite.todo.concurrent","suite.todo.sequential","suite.todo.shuffle","suite.skipIf.skip","suite.skipIf.only","suite.skipIf.concurrent","suite.skipIf.sequential","suite.skipIf.shuffle","suite.skipIf.todo","suite.runIf.skip","suite.runIf.only","suite.runIf.concurrent","suite.runIf.sequential","suite.runIf.shuffle","suite.runIf.todo","suite.skip.each","suite.only.each","suite.concurrent.each","suite.sequential.each","suite.shuffle.each","suite.todo.each","suite.skipIf.each","suite.runIf.each","suite.skip.only.concurrent","suite.skip.only.sequential","suite.skip.only.shuffle","suite.skip.only.todo","suite.skip.concurrent.only","suite.skip.concurrent.sequential","suite.skip.concurrent.shuffle","suite.skip.concurrent.todo","suite.skip.sequential.only","suite.skip.sequential.concurrent","suite.skip.sequential.shuffle","suite.skip.sequential.todo","suite.skip.shuffle.only","suite.skip.shuffle.concurrent","suite.skip.shuffle.sequential","suite.skip.shuffle.todo","suite.skip.todo.only","suite.skip.todo.concurrent","suite.skip.todo.sequential","suite.skip.todo.shuffle","suite.only.skip.concurrent","suite.only.skip.sequential","suite.only.skip.shuffle","suite.only.skip.todo","suite.only.concurrent.skip","suite.only.concurrent.sequential","suite.only.concurrent.shuffle","suite.only.concurrent.todo","suite.only.sequential.skip","suite.only.sequential.concurrent","suite.only.sequential.shuffle","suite.only.sequential.todo","suite.only.shuffle.skip","suite.only.shuffle.concurrent","suite.only.shuffle.sequential","suite.only.shuffle.todo","suite.only.todo.skip","suite.only.todo.concurrent","suite.only.todo.sequential","suite.only.todo.shuffle","suite.concurrent.skip.only","suite.concurrent.skip.sequential","suite.concurrent.skip.shuffle","suite.concurrent.skip.todo","suite.concurrent.only.skip","suite.concurrent.only.sequential","suite.concurrent.only.shuffle","suite.concurrent.only.todo","suite.concurrent.sequential.skip","suite.concurrent.sequential.only","suite.concurrent.sequential.shuffle","suite.concurrent.sequential.todo","suite.concurrent.shuffle.skip","suite.concurrent.shuffle.only","suite.concurrent.shuffle.sequential","suite.concurrent.shuffle.todo","suite.concurrent.todo.skip","suite.concurrent.todo.only","suite.concurrent.todo.sequential","suite.concurrent.todo.shuffle","suite.sequential.skip.only","suite.sequential.skip.concurrent","suite.sequential.skip.shuffle","suite.sequential.skip.todo","suite.sequential.only.skip","suite.sequential.only.concurrent","suite.sequential.only.shuffle","suite.sequential.only.todo","suite.sequential.concurrent.skip","suite.sequential.concurrent.only","suite.sequential.concurrent.shuffle","suite.sequential.concurrent.todo","suite.sequential.shuffle.skip","suite.sequential.shuffle.only","suite.sequential.shuffle.concurrent","suite.sequential.shuffle.todo","suite.sequential.todo.skip","suite.sequential.todo.only","suite.sequential.todo.concurrent","suite.sequential.todo.shuffle","suite.shuffle.skip.only","suite.shuffle.skip.concurrent","suite.shuffle.skip.sequential","suite.shuffle.skip.todo","suite.shuffle.only.skip","suite.shuffle.only.concurrent","suite.shuffle.only.sequential","suite.shuffle.only.todo","suite.shuffle.concurrent.skip","suite.shuffle.concurrent.only","suite.shuffle.concurrent.sequential","suite.shuffle.concurrent.todo","suite.shuffle.sequential.skip","suite.shuffle.sequential.only","suite.shuffle.sequential.concurrent","suite.shuffle.sequential.todo","suite.shuffle.todo.skip","suite.shuffle.todo.only","suite.shuffle.todo.concurrent","suite.shuffle.todo.sequential","suite.todo.skip.only","suite.todo.skip.concurrent","suite.todo.skip.sequential","suite.todo.skip.shuffle","suite.todo.only.skip","suite.todo.only.concurrent","suite.todo.only.sequential","suite.todo.only.shuffle","suite.todo.concurrent.skip","suite.todo.concurrent.only","suite.todo.concurrent.sequential","suite.todo.concurrent.shuffle","suite.todo.sequential.skip","suite.todo.sequential.only","suite.todo.sequential.concurrent","suite.todo.sequential.shuffle","suite.todo.shuffle.skip","suite.todo.shuffle.only","suite.todo.shuffle.concurrent","suite.todo.shuffle.sequential","suite.skipIf.skip.only","suite.skipIf.skip.concurrent","suite.skipIf.skip.sequential","suite.skipIf.skip.shuffle","suite.skipIf.skip.todo","suite.skipIf.only.skip","suite.skipIf.only.concurrent","suite.skipIf.only.sequential","suite.skipIf.only.shuffle","suite.skipIf.only.todo","suite.skipIf.concurrent.skip","suite.skipIf.concurrent.only","suite.skipIf.concurrent.sequential","suite.skipIf.concurrent.shuffle","suite.skipIf.concurrent.todo","suite.skipIf.sequential.skip","suite.skipIf.sequential.only","suite.skipIf.sequential.concurrent","suite.skipIf.sequential.shuffle","suite.skipIf.sequential.todo","suite.skipIf.shuffle.skip","suite.skipIf.shuffle.only","suite.skipIf.shuffle.concurrent","suite.skipIf.shuffle.sequential","suite.skipIf.shuffle.todo","suite.skipIf.todo.skip","suite.skipIf.todo.only","suite.skipIf.todo.concurrent","suite.skipIf.todo.sequential","suite.skipIf.todo.shuffle","suite.runIf.skip.only","suite.runIf.skip.concurrent","suite.runIf.skip.sequential","suite.runIf.skip.shuffle","suite.runIf.skip.todo","suite.runIf.only.skip","suite.runIf.only.concurrent","suite.runIf.only.sequential","suite.runIf.only.shuffle","suite.runIf.only.todo","suite.runIf.concurrent.skip","suite.runIf.concurrent.only","suite.runIf.concurrent.sequential","suite.runIf.concurrent.shuffle","suite.runIf.concurrent.todo","suite.runIf.sequential.skip","suite.runIf.sequential.only","suite.runIf.sequential.concurrent","suite.runIf.sequential.shuffle","suite.runIf.sequential.todo","suite.runIf.shuffle.skip","suite.runIf.shuffle.only","suite.runIf.shuffle.concurrent","suite.runIf.shuffle.sequential","suite.runIf.shuffle.todo","suite.runIf.todo.skip","suite.runIf.todo.only","suite.runIf.todo.concurrent","suite.runIf.todo.sequential","suite.runIf.todo.shuffle","suite.skip.only.each","suite.skip.concurrent.each","suite.skip.sequential.each","suite.skip.shuffle.each","suite.skip.todo.each","suite.only.skip.each","suite.only.concurrent.each","suite.only.sequential.each","suite.only.shuffle.each","suite.only.todo.each","suite.concurrent.skip.each","suite.concurrent.only.each","suite.concurrent.sequential.each","suite.concurrent.shuffle.each","suite.concurrent.todo.each","suite.sequential.skip.each","suite.sequential.only.each","suite.sequential.concurrent.each","suite.sequential.shuffle.each","suite.sequential.todo.each","suite.shuffle.skip.each","suite.shuffle.only.each","suite.shuffle.concurrent.each","suite.shuffle.sequential.each","suite.shuffle.todo.each","suite.todo.skip.each","suite.todo.only.each","suite.todo.concurrent.each","suite.todo.sequential.each","suite.todo.shuffle.each","suite.skipIf.skip.each","suite.skipIf.only.each","suite.skipIf.concurrent.each","suite.skipIf.sequential.each","suite.skipIf.shuffle.each","suite.skipIf.todo.each","suite.runIf.skip.each","suite.runIf.only.each","suite.runIf.concurrent.each","suite.runIf.sequential.each","suite.runIf.shuffle.each","suite.runIf.todo.each","xtest","xtest.each","xit","xit.each","fit","xdescribe","xdescribe.each","fdescribe"]);function ie(e,s){return e.sourceCode.getScope?e.sourceCode.getScope(s):e.getScope()}function $s(e,s){let t=ie(e,s);for(;t;){if(t.type==="module")return t;t=t.upper}return t}const E=(e,s,t)=>{const n=g(e,s);return n!==null&&t.includes(n.type)},g=(e,s)=>{const t=wt(e,s);return typeof t=="string"?null:t},Tt=new WeakMap,wt=(e,s)=>{let t=Tt.get(e);return t||(t=Ls(e,s),Tt.set(e,t),t)},Os=e=>e==="expect"?"expect":e==="expectTypeOf"?"expectTypeOf":e==="vi"?"vi":D.hasOwnProperty(e)?"describe":q.hasOwnProperty(e)?"test":qt.hasOwnProperty(e)?"hook":"unknown",Rs=e=>{const s=[];for(const t of e){if(t.parent?.type===r.MemberExpression&&t.parent.parent?.type===r.CallExpression)return{matcher:t,args:t.parent.parent.arguments,modifiers:s};const n=y(t);if(s.length===0){if(!N.hasOwnProperty(n))return"modifier-unknown"}else if(s.length===1){if(n!==N.not&&n!=N.have)return"modifier-unknown";const o=y(s[0]);if(o!==N.resolves&&o!==N.rejects&&o!==N.to)return"modifier-unknown"}else return"modifier-unknown";s.push(t)}return"matcher-not-found"},Ns=(e,s)=>{const t=Rs(e.members);return typeof t=="string"?t:{...e,type:s,...t}},At=e=>{let s=e,{parent:t}=e;for(;t;){if(t.type===r.CallExpression){s=t,t=t.parent;continue}if(t.type!==r.MemberExpression)break;t=t.parent}return s},Ls=(e,s)=>{const t=H(e);if(!t?.length)return null;const[n,...o]=t,i=y(t[t.length-1]);if(i==="each"&&e.callee.type!==r.CallExpression&&e.callee.type!==r.TaggedTemplateExpression||e.callee.type===r.TaggedTemplateExpression&&i!=="each")return null;const a=Bs(s,e,y(n));if(!a)return null;const c=a.original??a.local,l=[c,...o.map(y)];if(a.type!=="testContext"&&c!=="vi"&&c!=="expect"&&c!=="expectTypeOf"&&!Ms.has(l.join(".")))return null;const d={name:c,head:{...a,node:n},members:o},f=Os(c);if(f==="expect"||f==="expectTypeOf"){const u=Ns(d,f);return typeof u=="string"&&At(e)!==e?null:u==="matcher-not-found"&&e.parent?.type===r.MemberExpression?"matcher-not-called":u}return t.slice(0,t.length-1).some(u=>u.parent?.type!==r.MemberExpression)||e.parent?.type===r.CallExpression||e.parent?.type===r.MemberExpression?null:{...d,type:f}},Fs=(e,s)=>e&&s?[...e,...s]:null;function H(e){if(v(e))return[e];switch(e.type){case r.TaggedTemplateExpression:return H(e.tag);case r.MemberExpression:return Fs(H(e.object),H(e.property));case r.CallExpression:return H(e.callee)}return null}const Bs=(e,s,t)=>{const n=ie(e,s),o=Ct(n,t);return o==="local"?null:o==="testContext"?{local:t,original:null,type:"testContext"}:o?o.source==="vitest"?{original:o.imported,local:o.local,type:"import"}:null:{original:Ps(t,e),local:t,type:"global"}},Ps=(e,s)=>{const t=s.settings.vitest?.globalAliases??{},n=Object.entries(t).find(([o,i])=>i.includes(e));return n?n[0]:null},Us=({parent:e})=>{if(e?.type===r.CallExpression&&e.callee.type===r.Identifier)return q.hasOwnProperty(e.callee.name)},Ct=(e,s)=>{let t=e;for(;t!==null;){const n=t.set.get(s);if(n&&n.defs.length>0){const o=n.defs[n.defs.length-1],i=M(o.node)?o.node.params.find(l=>l.type===r.ObjectPattern):void 0;if(i){const l=i.properties.find(d=>d.type===r.Property);if((l?.key.type===r.Identifier?l.key:void 0)?.name===s)return"testContext"}const a=M(o.node)?o.node.params.find(l=>l.type===r.Identifier):void 0;if(a&&Us(a.parent))return"testContext";const c=Ws(o);return c?.local===s?c:"local"}t=t.upper}return null},js=e=>e.type===r.AwaitExpression?e.argument.type===r.ImportExpression?e.argument.source:null:e.type===r.CallExpression&&F(e.callee,"require")?e.arguments[0]??null:null,_s=e=>e.parent.type===r.TSImportEqualsDeclaration||e.node.type!==r.ImportSpecifier||e.node.imported.type!=r.Identifier||e.parent.importKind==="type"?null:{source:e.parent.source.value,imported:e.node.imported.name,local:e.node.local.name},Ws=e=>e.type==="Variable"?Ds(e):e.type==="ImportBinding"?_s(e):null,Ds=e=>{if(!e.node.init)return null;const s=js(e.node.init);return!s||!L(s)||e.name.parent?.type!==r.Property||!v(e.name.parent.key)?null:{source:U(s),imported:y(e.name.parent.key),local:e.name.name}},ae=(e,s)=>e.reduce((t,{references:n})=>t.concat(n.map(({identifier:o})=>o.parent).filter(o=>o?.type===r.CallExpression&&E(o,s,["test"]))),[]),P=e=>{const[s]=e.args;return s.type===r.SpreadElement?s:ce(s)},Hs=e=>e.type===r.TSAsExpression||e.type===r.TSTypeAssertion,ce=e=>Hs(e)?ce(e.expression):e,le="prefer-lowercase-title",Vs=e=>e.arguments[0]&&L(e.arguments[0]),Ks=e=>{const s=[];return e.includes(D.describe)&&s.push(...Object.keys(D)),e.includes(q.test)&&s.push(...Object.keys(q).filter(t=>t.endsWith(q.test))),e.includes(q.it)&&s.push(...Object.keys(q).filter(t=>t.endsWith(q.it))),s},Xs=m({name:le,meta:{type:"problem",docs:{description:"enforce lowercase titles",recommended:!1},fixable:"code",messages:{lowerCaseTitle:"`{{ method }}`s should begin with lowercase",fullyLowerCaseTitle:"`{{ method }}`s should be lowercase"},schema:[{type:"object",properties:{ignore:{type:"array",items:{type:"string",enum:[D.describe,q.test,q.it]}},allowedPrefixes:{type:"array",items:{type:"string"},additionalItems:!1},ignoreTopLevelDescribe:{type:"boolean",default:!1},lowercaseFirstCharacterOnly:{type:"boolean",default:!0}},additionalProperties:!1}]},defaultOptions:[{ignore:[],allowedPrefixes:[],ignoreTopLevelDescribe:!1,lowercaseFirstCharacterOnly:!0}],create:(e,[{ignore:s=[],allowedPrefixes:t=[],ignoreTopLevelDescribe:n=!1,lowercaseFirstCharacterOnly:o=!1}])=>{const i=Ks(s);let a=0;return{CallExpression(c){const l=g(c,e);if(!l||!Vs)return;if(l?.type==="describe"){if(a++,n&&a===1)return}else if(l?.type!=="test")return;const[d]=c.arguments,f=U(d);if(typeof f!="string"||t.some(x=>f.startsWith(x)))return;const u=f.charAt(0);i.includes(l.name)||o&&(!u||u===u.toLowerCase())||!o&&f===f.toLowerCase()||e.report({messageId:o?"lowerCaseTitle":"fullyLowerCaseTitle",node:c.arguments[0],data:{method:l.name},fix:x=>{const p=U(d),I=[d.range[0]+1,d.range[1]-1],k=o?p.substring(0,1).toLowerCase()+p.substring(1):p.toLowerCase();return[x.replaceTextRange(I,k)]}})},"CallExpression:exit"(c){E(c,e,["describe"])&&a--}}}}),ue="max-nested-describe",zs=m({name:ue,meta:{type:"problem",docs:{description:"require describe block to be less than set max value or default value",recommended:!1},schema:[{type:"object",properties:{max:{type:"number"}},additionalProperties:!1}],messages:{maxNestedDescribe:"Nested describe block should be less than set max value"}},defaultOptions:[{max:5}],create(e,[{max:s}]){const t=[];function n(i){i.parent?.type==="CallExpression"&&(i.parent.callee.type!=="Identifier"||i.parent.callee.name!=="describe"||(t.push(0),t.length>s&&e.report({node:i.parent,messageId:"maxNestedDescribe"})))}function o(i){i.parent?.type==="CallExpression"&&(i.parent.callee.type!=="Identifier"||i.parent.callee.name!=="describe"||t.pop())}return{FunctionExpression:n,"FunctionExpression:exit":o,ArrowFunctionExpression:n,"ArrowFunctionExpression:exit":o}}}),X="no-identical-title",vt=()=>({describeTitles:[],testTitles:[]}),Ys=m({name:X,meta:{type:"problem",docs:{description:"disallow identical titles",recommended:!1},fixable:"code",schema:[],messages:{multipleTestTitle:"Test is used multiple times in the same describe(suite) block",multipleDescribeTitle:"Describe is used multiple times in the same describe(suite) block"}},defaultOptions:[],create(e){const s=[vt()];return{CallExpression(t){const n=s[s.length-1],o=g(t,e);if(!o||((o.name==="describe"||o.name==="suite")&&s.push(vt()),o.members.find(c=>v(c,"each"))))return;const[i]=t.arguments;if(!i||!L(i))return;const a=U(i);o.type==="test"&&(n?.testTitles.includes(a)&&e.report({node:t,messageId:"multipleTestTitle"}),n?.testTitles.push(a)),o.type==="describe"&&(n?.describeTitles.includes(a)&&e.report({node:t,messageId:"multipleDescribeTitle"}),n?.describeTitles.push(a))},"CallExpression:exit"(t){E(t,e,["describe"])&&s.pop()}}}}),pe="no-focused-tests",de=e=>e.type==="Identifier"&&["it","test","describe"].includes(e.name),fe=e=>e.type==="Identifier"&&e.name==="only",Gs=m({name:pe,meta:{type:"problem",docs:{description:"disallow focused tests",recommended:!1},fixable:"code",schema:[{type:"object",properties:{fixable:{type:"boolean",default:!0}},additionalProperties:!1}],messages:{noFocusedTests:"Focused tests are not allowed"}},defaultOptions:[{fixable:!0}],create:e=>{const s=e.options[0]?.fixable;return{ExpressionStatement(t){if(t.expression.type==="CallExpression"){const{callee:n}=t.expression;if(n.type==="MemberExpression"&&de(n.object)&&fe(n.property)&&e.report({node:n.property,messageId:"noFocusedTests",fix:o=>s?o.removeRange([n.property.range[0]-1,n.property.range[1]]):null}),n.type==="TaggedTemplateExpression"){const o=n.tag.type==="MemberExpression"?n.tag.object:null;if(!o)return;o.type==="MemberExpression"&&de(o.object)&&fe(o.property)&&e.report({node:o.property,messageId:"noFocusedTests",fix:i=>s?i.removeRange([o.property.range[0]-1,o.property.range[1]]):null})}}},CallExpression(t){if(t.callee.type==="CallExpression"){const{callee:n}=t.callee;if(n.type==="MemberExpression"&&n.object.type==="MemberExpression"&&de(n.object.object)&&fe(n.object.property)&&n.property.type==="Identifier"&&n.property.name==="each"){const o=n.object.property;e.report({node:n.object.property,messageId:"noFocusedTests",fix:i=>s?i.removeRange([o.range[0]-1,o.range[1]]):null})}}}}}}),me="no-conditional-tests",Js=m({name:me,meta:{type:"problem",docs:{description:"disallow conditional tests",recommended:!1},schema:[],messages:{noConditionalTests:"Avoid using if conditions in a test"}},defaultOptions:[],create(e){return{Identifier:function(s){["test","it","describe"].includes(s.name)&&s.parent?.parent?.parent?.parent?.type==="IfStatement"&&e.report({node:s,messageId:"noConditionalTests"})}}}}),Qs={typecheck:!1};function z(e){const s=typeof e.vitest!="object"||e.vitest===null?{}:e.vitest;return{...Qs,...s}}const Y="expect-expect",Zs=m({name:Y,meta:{type:"suggestion",docs:{description:"enforce having expectation in test body",recommended:!1},schema:[{type:"object",properties:{assertFunctionNames:{type:"array",items:{type:"string"}},additionalTestBlockFunctions:{type:"array",items:{type:"string"}}},additionalProperties:!1}],messages:{noAssertions:"Test has no assertions"}},defaultOptions:[{assertFunctionNames:["expect","assert"],additionalTestBlockFunctions:[]}],create(e,[{assertFunctionNames:s=["expect"],additionalTestBlockFunctions:t=[]}]){const n=[];z(e.settings).typecheck&&s.push("expectTypeOf","assertType");const o=s.map(en);function i(a){for(const c of a){const l=c.type===r.CallExpression?n.indexOf(c):-1;if(c.type===r.FunctionDeclaration){const d=e.sourceCode.getDeclaredVariables(c),f=ae(d,e);i(f)}if(l!==-1){n.splice(l,1);break}}}return{CallExpression(a){if(a.callee.type===r.Identifier&&a.callee.name==="bench"||a?.callee?.type===r.MemberExpression&&a.callee.property.type===r.Identifier&&a.callee.property.name==="extend"||a?.callee?.type===r.MemberExpression&&a.callee.property.type===r.Identifier&&a.callee.property.name==="skip")return;const c=R(a)??"";if(E(a,e,["test"])||t.includes(c)){if(a.callee.type===r.MemberExpression&&v(a.callee.property,"todo"))return;n.push(a)}else o.some(l=>l.test(c))&&i(e.sourceCode.getAncestors(a))},"Program:exit"(){n.forEach(a=>{e.report({node:a.callee,messageId:"noAssertions"})})}}}});function en(e){const s=e.split(".").map(t=>t==="**"?"[_a-z\\d\\.]*":t.replace(/\*/gu,"[a-z\\d]*"));return new RegExp(`^${s.join("\\.")}(\\.|$)`,"ui")}const ye="consistent-test-it",St=(e,s,t)=>n=>[n.replaceText(e.type===r.MemberExpression?e.object:e,tn(s,t))];function tn(e,s){return e===q.fit?"test.only":e.startsWith("f")||e.startsWith("x")?e.charAt(0)+s:s}function he(e){return e===q.test?q.it:q.test}const sn=m({name:ye,meta:{type:"suggestion",fixable:"code",docs:{description:"enforce using test or it but not both",recommended:!1},messages:{consistentMethod:"Prefer using {{ testFnKeyWork }} instead of {{ oppositeTestKeyword }}",consistentMethodWithinDescribe:"Prefer using {{ testKeywordWithinDescribe }} instead of {{ oppositeTestKeyword }} within describe"},schema:[{type:"object",properties:{fn:{type:"string",enum:[q.test,q.it]},withinDescribe:{type:"string",enum:[q.test,q.it]}},additionalProperties:!1}]},defaultOptions:[{fn:q.test,withinDescribe:q.it}],create(e){const s=e.options[0]??{},t=s.fn||q.test,n=s?.withinDescribe||s?.fn||q?.it,o=t===n?t:void 0;let i=0;return{ImportDeclaration(a){if(o==null||a.source.type!=="Literal"||a.source.value!=="vitest")return;const c=he(o);for(const l of a.specifiers)l.type==="ImportSpecifier"&&l.imported.type==="Identifier"&&l.local.name===l.imported.name&&l.local.name===c&&e.report({node:l,data:{testFnKeyWork:t,oppositeTestKeyword:c},messageId:"consistentMethod",fix:d=>{const f=a.specifiers.filter(u=>u.local.name!==c);if(f.length>0){const u=f.map(p=>p.local.name).join(", "),x=a.specifiers.at(-1)?.range;return x?d.replaceTextRange([a.specifiers[0].range[0],x[1]],u):null}return d.replaceText(l.local,o)}})},CallExpression(a){if(a.callee.type===r.Identifier&&a.callee.name==="bench")return;const c=g(a,e);if(!c)return;if(c.type==="describe"){i++;return}const l=a.callee.type===r.TaggedTemplateExpression?a.callee.tag:a.callee.type===r.CallExpression?a.callee.callee:a.callee;if(c.type==="test"&&i===0&&!c.name.endsWith(t)){const d=he(t);e.report({node:a.callee,data:{testFnKeyWork:t,oppositeTestKeyword:d},messageId:"consistentMethod",fix:St(l,c.name,t)})}else if(c.type==="test"&&i>0&&!c.name.endsWith(n)){const d=he(n);e.report({messageId:"consistentMethodWithinDescribe",node:a.callee,data:{testKeywordWithinDescribe:n,oppositeTestKeyword:d},fix:St(l,c.name,n)})}},"CallExpression:exit"(a){E(a,e,["describe"])&&i--}}}}),ge="prefer-to-be",nn=e=>e.type===r.Literal&&e.value===null,on=e=>nn(P(e)),Mt=(e,s)=>F(P(e),s),rn=e=>Math.floor(e)!==Math.ceil(e),an=e=>{let s=P(e);return s.type===r.Literal&&typeof s.value=="number"&&rn(s.value)?!1:(s.type===r.UnaryExpression&&s.operator==="-"&&(s=s.argument),s.type===r.Literal?!("regex"in s):s.type===r.TemplateLiteral)},V=(e,s,t,n,o)=>{e.report({messageId:`useToBe${s}`,fix(i){const a=[K(i,t.matcher,`toBe${s}`)];return t.args?.length&&s!==""&&a.push(It(i,e,n,0)),o&&a.push(i.removeRange([o.range[0]-1,o.range[1]])),a},node:t.matcher})},cn=m({name:ge,meta:{type:"suggestion",docs:{description:"enforce using toBe()",recommended:!1},schema:[],fixable:"code",messages:{useToBe:"Use `toBe` instead",useToBeUndefined:"Use `toBeUndefined()` instead",useToBeDefined:"Use `toBeDefined()` instead",useToBeNull:"Use `toBeNull()` instead",useToBeNaN:"Use `toBeNaN()` instead"}},defaultOptions:[],create(e){return{CallExpression(s){const t=g(s,e);if(t?.type!=="expect")return;const n=y(t.matcher),o=t.modifiers.find(i=>y(i)==="not");if(o&&["toBeUndefined","toBeDefined"].includes(n)){V(e,n==="toBeDefined"?"Undefined":"Defined",t,s,o);return}if(!(!B.hasOwnProperty(n)||t.args.length===0)){if(on(t)){V(e,"Null",t,s);return}if(Mt(t,"undefined")){V(e,o?"Defined":"Undefined",t,s);return}if(Mt(t,"NaN")){V(e,"NaN",t,s);return}an(t)&&n!==B.toBe&&V(e,"",t,s)}}}}}),ke="no-hooks",ln=m({name:ke,meta:{type:"suggestion",docs:{description:"disallow setup and teardown hooks",recommended:!1},schema:[{type:"object",properties:{allow:{type:"array",contains:["beforeAll","beforeEach","afterAll","afterEach"]}},additionalProperties:!1}],messages:{unexpectedHook:"Unexpected '{{ hookName }}' hook"}},defaultOptions:[{allow:[]}],create(e,[{allow:s=[]}]){return{CallExpression(t){const n=g(t,e);n?.type==="hook"&&!s.includes(n.name)&&e.report({node:t,messageId:"unexpectedHook",data:{hookName:n.name}})}}}}),be="no-restricted-vi-methods",un=m({name:be,meta:{type:"suggestion",docs:{description:"disallow specific `vi.` methods",recommended:!1},schema:[{type:"object",additionalProperties:{type:["string","null"]}}],messages:{restrictedViMethod:"Use of `{{ restriction }}` is disallowed",restrictedViMethodWithMessage:"{{ message }}"}},defaultOptions:[{}],create(e,[s]){return{CallExpression(t){const n=g(t,e);if(n?.type!=="vi"||n.members.length===0)return;const o=y(n.members[0]);if(o in s){const i=s[o];e.report({messageId:i?"restrictedViMethodWithMessage":"restrictedViMethod",data:{message:i,restriction:o},loc:{start:n.members[0].loc.start,end:n.members[n.members.length-1].loc.end}})}}}}}),xe="consistent-test-filename",$t=/.*\.test\.[tj]sx?$/,G=/.*\.(test|spec)\.[tj]sx?$/,pn=m({name:xe,meta:{type:"problem",docs:{recommended:!1,requiresTypeChecking:!1,description:"require .spec test file pattern"},messages:{consistentTestFilename:"Use test file name pattern {{ pattern }}"},schema:[{type:"object",additionalProperties:!1,properties:{pattern:{format:"regex",default:$t.source},allTestPattern:{format:"regex",default:G.source}}}]},defaultOptions:[{pattern:G.source,allTestPattern:G.source}],create:e=>{const s=e.options[0]??{},{pattern:t=$t,allTestPattern:n=G}=s,o=typeof t=="string"?new RegExp(t):t,i=typeof n=="string"?new RegExp(n):n,{filename:a}=e;return i.test(a)?{Program:c=>{o.test(a)||e.report({node:c,messageId:"consistentTestFilename",data:{pattern:o.source}})}}:{}}}),Ie="max-expects",dn=m({name:Ie,meta:{docs:{requiresTypeChecking:!1,recommended:!1,description:"enforce a maximum number of expect per test"},messages:{maxExpect:"Too many assertion calls ({{ count }}) - maximum allowed is {{ max }}"},type:"suggestion",schema:[{type:"object",properties:{max:{type:"number"}},additionalProperties:!1}]},defaultOptions:[{max:5}],create(e,[{max:s}]){let t=0;const n=o=>{(o.parent?.type!==r.CallExpression||E(o.parent,e,["test"]))&&(t=0)};return{FunctionExpression:n,"FunctionExpression:exit":n,ArrowFunctionExpression:n,"ArrowFunctionExpression:exit":n,CallExpression(o){const i=g(o,e);i?.type!=="expect"||i.head.node.parent?.type===r.MemberExpression||(t+=1,t>s&&e.report({node:o,messageId:"maxExpect",data:{count:t,max:s}}))}}}}),qe="no-alias-methods",fn=m({name:qe,meta:{docs:{description:"disallow alias methods",requiresTypeChecking:!1,recommended:!1},messages:{noAliasMethods:"Replace {{ alias }}() with its canonical name {{ canonical }}()"},type:"suggestion",fixable:"code",schema:[]},defaultOptions:[],create(e){const s={toBeCalled:"toHaveBeenCalled",toBeCalledTimes:"toHaveBeenCalledTimes",toBeCalledWith:"toHaveBeenCalledWith",lastCalledWith:"toHaveBeenLastCalledWith",nthCalledWith:"toHaveBeenNthCalledWith",toReturn:"toHaveReturned",toReturnTimes:"toHaveReturnedTimes",toReturnWith:"toHaveReturnedWith",lastReturnedWith:"toHaveLastReturnedWith",nthReturnedWith:"toHaveNthReturnedWith",toThrowError:"toThrow"};return{CallExpression(t){const n=g(t,e);if(n?.type!=="expect")return;const{matcher:o}=n,i=y(o);if(i in s){const a=s[i];e.report({messageId:"noAliasMethods",data:{alias:i,canonical:a},node:o,fix:c=>[K(c,o,a)]})}}}}}),J="no-commented-out-tests";function mn(e){return/^\s*[xf]?(test|it|describe)(\.\w+|\[['"]\w+['"]\])?\s*\(/mu.test(e.value)}const yn=m({name:J,meta:{docs:{description:"disallow commented out tests",requiresTypeChecking:!1,recommended:!1},messages:{noCommentedOutTests:"Remove commented out tests - you may want to use `skip` or `only` instead"},schema:[],type:"suggestion"},defaultOptions:[],create(e){const{sourceCode:s}=e;function t(n){mn(n)&&e.report({messageId:"noCommentedOutTests",node:n})}return{Program(){s.getAllComments().forEach(t)}}}}),Ee="no-conditional-expect",Ot=e=>e.callee.type===r.MemberExpression&&v(e.callee.property,"catch"),hn=m({name:Ee,meta:{type:"problem",docs:{description:"disallow conditional expects",requiresTypeChecking:!1,recommended:!1},messages:{noConditionalExpect:"Avoid calling `expect` inside conditional statements"},schema:[]},defaultOptions:[],create(e){let s=0,t=!1,n=!1;const o=()=>t&&s++,i=()=>t&&s--;return{FunctionDeclaration(a){const c=e.sourceCode.getDeclaredVariables(a);ae(c,e).length>0&&(t=!0)},CallExpression(a){const{type:c}=g(a,e)??{};c==="test"&&(t=!0),Ot(a)&&(n=!0),t&&c==="expect"&&s>0&&e.report({messageId:"noConditionalExpect",node:a}),n&&c==="expect"&&e.report({messageId:"noConditionalExpect",node:a})},"CallExpression:exit"(a){E(a,e,["test"])&&(t=!1),Ot(a)&&(n=!1)},CatchClause:o,"CatchClause:exit":i,IfStatement:o,"IfStatement:exit":i,SwitchStatement:o,"SwitchStatement:exit":i,ConditionalExpression:o,"ConditionalExpression:exit":i,LogicalExpression:o,"LogicalExpression:exit":i}}}),Q="no-import-node-test",gn=m({name:Q,meta:{docs:{description:"disallow importing `node:test`",recommended:!1},type:"suggestion",messages:{noImportNodeTest:"Import from `vitest` instead of `node:test`"},fixable:"code",schema:[]},defaultOptions:[],create(e){return{ImportDeclaration(s){s.source.value==="node:test"&&e.report({messageId:"noImportNodeTest",node:s,fix:t=>t.replaceText(s.source,s.source.raw.replace("node:test","vitest"))})}}}}),Te="no-conditional-in-test",kn=m({name:Te,meta:{docs:{description:"disallow conditional tests",requiresTypeChecking:!1,recommended:!1},messages:{noConditionalInTest:"Remove conditional tests"},schema:[],type:"problem"},defaultOptions:[],create(e){return{IfStatement(s){s.parent?.parent?.parent?.type==="CallExpression"&&E(s.parent?.parent?.parent,e,["test","it"])&&e.report({messageId:"noConditionalInTest",node:s})}}}}),we="no-disabled-tests",bn=m({name:we,meta:{type:"suggestion",docs:{description:"disallow disabled tests",recommended:!1},messages:{missingFunction:"Test is missing function argument",pending:"Call to pending()",pendingSuite:"Call to pending() within test suite",pendingTest:"Call to pending() within test",disabledSuite:"Disabled test suite - if you want to skip a test suite temporarily, use .todo() instead",disabledTest:"Disabled test - if you want to skip a test temporarily, use .todo() instead"},schema:[]},defaultOptions:[],create(e){let s=0,t=0;return{CallExpression(n){const o=g(n,e);if(!o)return;o.type==="describe"&&s++,o.type==="test"&&(t++,n.arguments.length<2&&o.members.every(a=>y(a)==="skip")&&e.report({messageId:"missingFunction",node:n}));const i=o.members.find(a=>y(a)==="skip");(o.name.startsWith("x")||i!==void 0)&&e.report({messageId:o.type==="describe"?"disabledSuite":"disabledTest",node:i??o.head.node})},"CallExpression:exit"(n){const o=g(n,e);o&&(o.type==="describe"&&s--,o.type==="test"&&t--)},'CallExpression[callee.name="pending"]'(n){const o=ie(e,n);Ct(o,"pending")||(t>0?e.report({messageId:"pendingTest",node:n}):s>0?e.report({messageId:"pendingSuite",node:n}):e.report({messageId:"pending",node:n}))}}}}),Ae="no-done-callback",xn=(e,s,t)=>{if(s)return e.arguments[1];const n=g(e,t);return n?.type==="hook"&&e.arguments.length>=1?e.arguments[0]:n?.type==="test"&&e.arguments.length>=2?e.arguments[1]:null},In=m({name:Ae,meta:{type:"suggestion",docs:{description:"disallow using a callback in asynchronous tests and hooks",recommended:!1},deprecated:!0,schema:[],messages:{noDoneCallback:"Return a promise instead of relying on callback parameter",suggestWrappingInPromise:"Wrap in `new Promise({{ callback }} => ...`",useAwaitInsteadOfCallback:"Use `await` instead of callback in async function"},hasSuggestions:!0},defaultOptions:[],create(e){return{CallExpression(s){const t=/\.each$|\.concurrent$/.test(R(s.callee)??"");if(t&&s.callee.type!==r.TaggedTemplateExpression||e.sourceCode.getAncestors(s).some(a=>a.type!==r.CallExpression||!E(a,e,["describe","test"])?!1:a.callee.type===r.MemberExpression&&v(a.callee.property,"concurrent")))return;const n=xn(s,t,e),o=Number(t);if(!n||!M(n)||n.params.length!==1+o)return;const i=n.params[o];if(i.type!==r.Identifier){e.report({node:i,messageId:"noDoneCallback"});return}if(n.async){e.report({node:i,messageId:"useAwaitInsteadOfCallback"});return}e.report({node:s,messageId:"noDoneCallback",suggest:[{messageId:"suggestWrappingInPromise",data:{callback:i.name},fix(a){const{body:c,params:l}=n,{sourceCode:d}=e,f=d.getFirstToken(c),u=d.getLastToken(c),[x]=l,p=l[l.length-1],I=d.getTokenBefore(x);let k=d.getTokenAfter(p);if(k?.value===","&&(k=d.getTokenAfter(k)),!f||!u||!I||!k)throw new Error(`Unexpected null when attempting to fix ${e.filename} - please file an issue at https://github/veritem/eslint-plugin-vitest`);let b=a.replaceText(x,"()");I.value==="("&&k.value===")"&&(b=a.removeRange([I.range[1],k.range[0]]));let A=`new Promise(${i.name} => `,w=")",T=!0;return c.type===r.BlockStatement&&(A=`return ${A}{`,w+="}",T=!1),[b,T?a.insertTextBefore(f,A):a.insertTextAfter(f,A),a.insertTextAfter(u,w)]}}]})}}}}),Ce="no-duplicate-hooks",qn=m({name:Ce,meta:{docs:{recommended:!1,description:"disallow duplicate hooks and teardown hooks",requiresTypeChecking:!1},messages:{noDuplicateHooks:"Duplicate {{ hook }} in describe block"},schema:[],type:"suggestion"},defaultOptions:[],create(e){const s=[{}];return{CallExpression(t){const n=g(t,e);if(n?.type==="describe"&&s.push({}),n?.type!=="hook")return;const o=s[s.length-1];o[n.name]||=0,o[n.name]+=1,o[n.name]>1&&e.report({messageId:"noDuplicateHooks",data:{hook:n.name},node:t})},"CallExpression:exit"(t){E(t,e,["describe"])&&s.pop()}}}}),ve="no-large-snapshots",Rt=(e,s,{maxSize:t=50,allowedSnapshots:n={}})=>{const o=s.loc.start.line,i=s.loc.end.line-o;if(!Object.keys(n).every(Es))throw new Error("All paths for allowedSnapshots must be absolute. You can use JS config and `path.resolve`");let a=!1;if(s.type===r.ExpressionStatement&&"left"in s.expression&&s.expression.left.type===r.MemberExpression&&v(s.expression.left.property)){const c=e.filename,l=n[c];if(l){const d=y(s.expression.left.property);a=l.some(f=>f instanceof RegExp?f.test(d):d===f)}}!a&&i>t&&e.report({node:s,messageId:t===0?"noSnapShot":"tooLongSnapShot",data:{lineCount:i,lineLimit:t}})},En=m({name:ve,meta:{docs:{description:"disallow large snapshots",recommended:!1},messages:{noSnapShot:"`{{ lineCount }}`s should begin with lowercase",tooLongSnapShot:"Expected vitest snapshot to be smaller than {{ lineLimit }} lines but was {{ lineCount }} lines long"},type:"suggestion",schema:[{type:"object",properties:{maxSize:{type:"number"},inlineMaxSize:{type:"number"},allowedSnapshots:{type:"object",additionalProperties:{type:"array"}}},additionalProperties:!1}]},defaultOptions:[{}],create(e,[s]){return e.filename.endsWith(".snap")?{ExpressionStatement(t){Rt(e,t,s)}}:{CallExpression(t){const n=g(t,e);n?.type==="expect"&&["toMatchInlineSnapshot","toThrowErrorMatchingInlineSnapshot"].includes(y(n.matcher))&&n.args.length&&Rt(e,n.args[0],{...s,maxSize:s.inlineMaxSize??s.maxSize})}}}}),Se="no-interpolation-in-snapshots",Tn=m({name:Se,meta:{type:"problem",docs:{description:"disallow string interpolation in snapshots",recommended:!1},fixable:"code",schema:[],messages:{noInterpolationInSnapshots:"Do not use string interpolation in snapshots"}},defaultOptions:[],create(e){return{CallExpression(s){const t=g(s,e);t?.type==="expect"&&["toMatchInlineSnapshot","toThrowErrorMatchingInlineSnapshot"].includes(y(t.matcher))&&t.args.forEach(n=>{n.type===r.TemplateLiteral&&n.expressions.length>0&&e.report({messageId:"noInterpolationInSnapshots",node:n})})}}}}),Nt="__mocks__",wn=e=>e.split(Ts.sep).includes(Nt),Lt=e=>L(e)&&wn(U(e)),Me="no-mocks-import",An=m({name:Me,meta:{type:"problem",docs:{description:"disallow importing from __mocks__ directory",recommended:!1},messages:{noMocksImport:`Mocks should not be manually imported from a ${Nt} directory. Instead use \`vi.mock\` and import from the original module path`},schema:[]},defaultOptions:[],create(e){return{ImportDeclaration(s){Lt(s.source)&&e.report({node:s,messageId:"noMocksImport"})},'CallExpression[callee.name="require"]'(s){const[t]=s.arguments;t&&Lt(t)&&e.report({node:t,messageId:"noMocksImport"})}}}}),$e="no-restricted-matchers",Cn=(e,s)=>N.hasOwnProperty(s)||s.endsWith(".not")?e.startsWith(s):e===s,vn=m({name:$e,meta:{docs:{description:"disallow the use of certain matchers",recommended:!1},type:"suggestion",schema:[{type:"object",additionalProperties:{type:["string","null"]}}],messages:{restrictedChain:"use of {{ restriction }} is disallowed",restrictedChainWithMessage:"{{ message }}"}},defaultOptions:[{}],create(e,[s]){return{CallExpression(t){const n=g(t,e);if(n?.type!=="expect")return;const o=n.members.map(i=>y(i)).join(".");for(const[i,a]of Object.entries(s))if(Cn(o,i)){e.report({messageId:a?"restrictedChainWithMessage":"restrictedChain",data:{message:a,restriction:i},loc:{start:n.members[0].loc.start,end:n.members[n.members.length-1].loc.end}});break}}}}}),Oe="no-standalone-expect",Ft=(e,s)=>{const t=e.parent;if(!t)throw new Error("Unexpected block statement. If you feel like this is a bug report https://github.com/veritem/eslint-plugin-vitest/issues/new");if(t.type===r.FunctionDeclaration)return"function";if(M(t)&&t.parent){const n=t.parent;if(n.type===r.VariableDeclarator)return"function";if(n.type===r.CallExpression&&E(n,s,["describe"]))return"describe"}return null},Sn=m({name:Oe,meta:{docs:{description:"disallow using `expect` outside of `it` or `test` blocks",recommended:!1},type:"suggestion",messages:{noStandaloneExpect:"Expect must be called inside a test block"},schema:[{type:"object",properties:{additionalTestBlockFunctions:{type:"array",items:{type:"string"}}},additionalProperties:!1}]},defaultOptions:[{additionalTestBlockFunctions:[]}],create(e,[{additionalTestBlockFunctions:s=[]}]){const t=[],n=o=>s.includes(R(o)||"");return{CallExpression(o){const i=g(o,e);if(i?.type==="expect"){if(i.head.node.parent?.type===r.MemberExpression&&i.members.length===1&&!["assertions","hasAssertions"].includes(y(i.members[0])))return;const a=t[t.length-1];(!a||a===D.describe)&&e.report({node:o,messageId:"noStandaloneExpect"});return}(i?.type==="test"||n(o))&&t.push("test"),o.callee.type===r.TaggedTemplateExpression&&t.push("template")},"CallExpression:exit"(o){const i=t[t.length-1];(i==="test"&&(E(o,e,["test"])||n(o))&&o.callee.type!==r.MemberExpression||i==="template"&&o.callee.type===r.TaggedTemplateExpression)&&t.pop()},BlockStatement(o){const i=Ft(o,e);i&&t.push(i)},"BlockStatement:exit"(o){Ft(o,e)&&t.pop()},ArrowFunctionExpression(o){o.parent?.type!==r.CallExpression&&t.push("arrow")},"ArrowFunctionExpression:exit"(){t[t.length-1]==="arrow"&&t.pop()}}}}),Re="no-test-prefixes",Mn=m({name:Re,meta:{docs:{description:"Disallow using the `f` and `x` prefixes in favour of `.only` and `.skip`",recommended:!1},type:"suggestion",messages:{usePreferredName:'Use "{{ preferredNodeName }}" instead'},fixable:"code",schema:[]},defaultOptions:[],create(e){return{CallExpression(s){const t=g(s,e);if(t?.type!=="describe"&&t?.type!=="test"||t.name[0]!=="f"&&t.name[0]!=="x")return;const n=[t.name.slice(1),t.name[0]==="f"?"only":"skip",...t.members.map(i=>y(i))].join("."),o=s.callee.type===r.TaggedTemplateExpression?s.callee.tag:s.callee.type===r.CallExpression?s.callee.callee:s.callee;e.report({messageId:"usePreferredName",node:s.callee,data:{preferredNodeName:n},fix:i=>[i.replaceText(o,n)]})}}}}),Ne="no-test-return-statement",$n=e=>{const[,s]=e;return s&&M(s)&&s.body.type===r.BlockStatement?s.body.body:[]},On=m({name:Ne,meta:{type:"problem",docs:{description:"disallow return statements in tests",recommended:!1},schema:[],messages:{noTestReturnStatement:"Return statements are not allowed in tests"}},defaultOptions:[],create(e){return{CallExpression(s){if(!E(s,e,["test"]))return;const t=$n(s.arguments).find(n=>n.type===r.ReturnStatement);t&&e.report({messageId:"noTestReturnStatement",node:t})},FunctionDeclaration(s){const t=e.sourceCode.getDeclaredVariables(s);if(ae(t,e).length===0)return;const n=s.body.body.find(o=>o.type===r.ReturnStatement);n&&e.report({messageId:"noTestReturnStatement",node:n})}}}}),Le="prefer-called-with",Rn=m({name:Le,meta:{docs:{description:"enforce using `toBeCalledWith()` or `toHaveBeenCalledWith()`",recommended:!1},messages:{preferCalledWith:"Prefer {{ matcherName }}With(/* expected args */)"},type:"suggestion",fixable:"code",schema:[]},defaultOptions:[],create(e){return{CallExpression(s){const t=g(s,e);if(t?.type!=="expect"||t.modifiers.some(i=>y(i)==="not"))return;const{matcher:n}=t,o=y(n);["toBeCalled","toHaveBeenCalled"].includes(o)&&e.report({data:{matcherName:o},messageId:"preferCalledWith",node:n,fix:i=>[i.replaceText(n,`${o}With`)]})}}}}),Z="valid-title",Nn=e=>["f","x"].includes(e.charAt(0))?e.substring(1):e,Bt=e=>e.type===r.TemplateLiteral?`\`${e.quasis[0].value.raw}\``:e.raw,Pt={type:"array",items:{type:"string"},minItems:1,maxItems:2,additionalItems:!1},ee=e=>{const[s,t]=Array.isArray(e)?e:[e];return[new RegExp(s,"u"),t]};function Ln(e){return!!(e.flags&W.TypeFlags.StringLike)}const Ut=e=>{if(typeof e=="string"||Array.isArray(e)){const s=ee(e);return{describe:s,test:s,it:s}}return{describe:e.describe?ee(e.describe):null,test:e.test?ee(e.test):null,it:e.it?ee(e.it):null}},jt=e=>L(e.right)?!0:e.left.type===r.BinaryExpression?jt(e.left):L(e.left),Fn=m({name:Z,meta:{docs:{description:"enforce valid titles",recommended:!1},messages:{titleMustBeString:"Test title must be a string, a function or class name",emptyTitle:"{{ functionName }} should not have an empty title",duplicatePrefix:"should not have duplicate prefix",accidentalSpace:"should not have leading or trailing spaces",disallowedWord:'"{{ word }}" is not allowed in test title',mustNotMatch:"{{ functionName }} should not match {{ pattern }}",mustMatch:"{{ functionName }} should match {{ pattern }}",mustNotMatchCustom:"{{ message }}",mustMatchCustom:"{{ message }}"},type:"suggestion",schema:[{type:"object",properties:{ignoreTypeOfDescribeName:{type:"boolean",default:!1},allowArguments:{type:"boolean",default:!1},disallowedWords:{type:"array",items:{type:"string"}}},patternProperties:{[/^must(?:Not)?Match$/u.source]:{oneOf:[{type:"string"},Pt,{type:"object",propertyNames:{type:"string",enum:["describe","test","it"]},additionalProperties:{oneOf:[{type:"string"},Pt]}}]}},additionalProperties:!1}],fixable:"code"},defaultOptions:[{ignoreTypeOfDescribeName:!1,allowArguments:!1,disallowedWords:[]}],create(e,[{ignoreTypeOfDescribeName:s,allowArguments:t,disallowedWords:n=[],mustNotMatch:o,mustMatch:i}]){const a=new RegExp(`\\b(${n.join("|")})\\b`,"iu"),c=Ut(o??{}),l=Ut(i??{}),d=z(e.settings);return{CallExpression(f){const u=g(f,e);if(u?.type!=="describe"&&u?.type!=="test"&&u?.type!=="it"||u.members&&u.members[0]&&u.members[0].type===r.Identifier&&u.members[0].name==="extend")return;const x=O=>{e.report({messageId:"emptyTitle",data:{functionName:u.type==="describe"?D.describe:q.test},node:O})},[p]=f.arguments;if(d.typecheck){const O=re.getParserServices(e).getTypeAtLocation(p);if(Et(O))return;if(Ln(O)){L(p)&&!U(p)&&x(f);return}}if(!p||t&&p.type===r.Identifier)return;if(!L(p)){if(p.type===r.BinaryExpression&&jt(p))return;p.type!==r.TemplateLiteral&&!(s&&u.type==="describe")&&e.report({messageId:"titleMustBeString",loc:p.loc});return}const I=U(p);if(!I){x(f);return}if(n.length>0){const O=a.exec(I);if(O){e.report({messageId:"disallowedWord",data:{word:O[1]},node:p});return}}I.trim().length!==I.length&&e.report({messageId:"accidentalSpace",node:p,fix:O=>[O.replaceTextRange(p.range,Bt(p).replace(/^([`'"]) +?/u,"$1").replace(/ +?([`'"])$/u,"$1"))]});const k=Nn(u.name),[b]=I.split(" ");b.toLowerCase()===k&&e.report({messageId:"duplicatePrefix",node:p,fix:O=>[O.replaceTextRange(p.range,Bt(p).replace(/^([`'"]).+? /u,"$1"))]});const A=k,[w,T]=c[A]??[];if(w&&w.test(I)){e.report({messageId:T?"mustNotMatchCustom":"mustNotMatch",node:p,data:{functionName:A,pattern:w,message:T}});return}const[C,_]=l[A]??[];C&&(C.test(I)||e.report({messageId:_?"mustMatchCustom":"mustMatch",node:p,data:{functionName:A,pattern:C,message:_}}))}}}}),te="valid-expect",_t=["toReject","toResolve"],Bn=e=>(e.type===r.ArrayExpression&&e.parent&&e.parent.type===r.CallExpression&&(e=e.parent),e.type===r.CallExpression&&e.callee.type===r.MemberExpression&&v(e.callee.object,"Promise")&&e.parent?e:null),Wt=({start:e,end:s})=>`${e.line}:${e.column}-${s.line}:${s.column}`,Pn=e=>e.parent.type===r.Property&&e.type===r.FunctionExpression?e.parent:e;function Dt(e){const s=e.parent?.parent;return s&&s.type===r.CallExpression&&s.callee.type===r.MemberExpression&&v(s.callee.property)&&["then","catch"].includes(y(s.callee.property))&&s.parent?Dt(s):e}const Un=e=>e.parent?.parent&&[r.CallExpression,r.ArrayExpression].includes(e.parent.type)?Bn(e.parent):null,Ht=({parent:e})=>e?M(e)?e:Ht(e):null,Vt=(e,s)=>s&&e.type===r.ReturnStatement?!0:e.type===r.ConditionalExpression&&e.parent?Vt(e.parent,s):[r.ArrowFunctionExpression,r.AwaitExpression].includes(e.type),jn=m({name:te,meta:{docs:{description:"enforce valid `expect()` usage",recommended:!1},messages:{tooManyArgs:"Expect takes at most {{ amount}} argument{{ s }}",notEnoughArgs:"Expect requires at least {{ amount }} argument{{ s }}",modifierUnknown:"Expect has an unknown modifier",matcherNotFound:"Expect must have a corresponding matcher call",matcherNotCalled:"Matchers must be called to assert",asyncMustBeAwaited:"Async assertions must be awaited{{ orReturned }}",promisesWithAsyncAssertionsMustBeAwaited:"Promises which return async assertions must be awaited{{ orReturned }}"},type:"suggestion",fixable:"code",schema:[{type:"object",properties:{alwaysAwait:{type:"boolean",default:!1},asyncMatchers:{type:"array",items:{type:"string"}},minArgs:{type:"number",minimum:1},maxArgs:{type:"number",minimum:1}},additionalProperties:!1}]},defaultOptions:[{alwaysAwait:!1,asyncMatchers:_t,minArgs:1,maxArgs:1}],create:(e,[{alwaysAwait:s,asyncMatchers:t=_t,minArgs:n=1,maxArgs:o=1}])=>{const i=new Set,a=[],c=f=>i.add(Wt(f)),l=f=>i.has(Wt(f)),d=f=>{let u=f,{parent:x}=f;for(;x&&x.type===r.MemberExpression;)u=x,x=x.parent;return u};return{CallExpression(f){const u=wt(f,e),x=z(e.settings);if(typeof u=="string"){const C=f.parent?.type===r.MemberExpression?d(f.parent).property:f;if(u==="matcher-not-found"){e.report({messageId:"matcherNotFound",node:C});return}if(u==="matcher-not-called"&&e.report({messageId:v(C)&&N.hasOwnProperty(y(C))?"matcherNotFound":"matcherNotCalled",node:C}),u==="modifier-unknown"){e.report({messageId:"modifierUnknown",node:C});return}return}else if(u?.type==="expectTypeOf"&&x.typecheck||u?.type!=="expect"||u.modifiers.some(C=>C.type===r.Identifier&&C.name=="to"))return;const{parent:p}=u.head.node;if(p?.type!==r.CallExpression)return;if(p.arguments.length<n){const C=y(u.head.node).length,_={start:{column:p.loc.start.column+C,line:p.loc.start.line},end:{column:p.loc.start.column+C+1,line:p.loc.start.line}};e.report({messageId:"notEnoughArgs",data:{amount:n,s:n===1?"":"s"},node:p,loc:_})}if(p.arguments.length>o){if(p.arguments.length===2){const Is=p.arguments[1].type===r.Literal&&typeof p.arguments[1].value=="string",qs=p.arguments[1].type===r.TemplateLiteral;if(Is||qs)return}const{start:C}=p.arguments[o].loc,{end:_}=p.arguments[p.arguments.length-1].loc,O={start:C,end:{column:_.column+1,line:_.line}};e.report({messageId:"tooManyArgs",data:{amount:o,s:o===1?"":"s"},node:p,loc:O})}const{matcher:I}=u,k=I.parent.parent,b=u.modifiers.some(C=>y(C)!=="not")||t.includes(y(I));if(!k?.parent||!b)return;const A=k.parent.type===r.ArrayExpression,w=Dt(k),T=Un(w)||w;T.parent&&!Vt(T.parent,!s)&&!l(T.loc)&&(a.push({messageId:T===w?"asyncMustBeAwaited":"promisesWithAsyncAssertionsMustBeAwaited",node:T}),A&&c(T.loc))},"Program:exit"(){const f=[];a.forEach(({node:u,messageId:x},p)=>{const I=s?"":" or returned";e.report({loc:u.loc,data:{orReturned:I},messageId:x,node:u,fix(k){const b=Ht(u);if(!b)return null;const A=f.some(T=>T.text==="async ");if(!b.async&&!A){const T=Pn(b);f.push(k.insertTextBefore(T,"async "))}const w=u.parent?.type===r.ReturnStatement?u.parent:null;if(s&&w){const T=e.sourceCode.getText(w).replace("return","await");f.push(k.replaceText(w,T))}else f.push(k.insertTextBefore(u,"await "));return p===a.length-1?f:null}})})}}}}),se=e=>e.type===r.Literal&&typeof e.value=="boolean",_n=e=>{const s=y(e.matcher);if(["toBeTruthy","toBeFalsy"].includes(s))return!0;if(e.args.length!==1)return!1;const t=P(e);return B.hasOwnProperty(s)&&se(t)},Wn=(e,s)=>e.type===r.BinaryExpression&&e.operator==="instanceof"&&v(e.right,s),Kt=e=>e.arguments.length===1,Fe="prefer-to-be-object",Dn=m({name:Fe,meta:{type:"suggestion",docs:{description:"enforce using toBeObject()",recommended:!1},fixable:"code",messages:{preferToBeObject:"Prefer toBeObject() to test if a value is an object"},schema:[]},defaultOptions:[],create(e){return{CallExpression(s){const t=g(s,e);if(t?.type!=="expectTypeOf")return;if(Ss(t,"Object")){e.report({node:t.matcher,messageId:"preferToBeObject",fix:i=>[i.replaceTextRange([t.matcher.range[0],t.matcher.range[1]+8],"toBeObject()")]});return}const{parent:n}=t.head.node;if(n?.type!==r.CallExpression)return;const[o]=n.arguments;!o||!_n(t)||!Wn(o,"Object")||e.report({node:t.matcher,messageId:"preferToBeObject",fix(i){const a=[i.replaceText(t.matcher,"toBeObject"),i.removeRange([o.left.range[1],o.range[1]])];let c=y(t.matcher)==="toBeFalsy";if(t.args.length){const[l]=t.args;a.push(i.remove(l)),c=l.type===r.Literal&&ce(l).value===!1}if(c){const l=t.modifiers.find(d=>y(d)==="not");a.push(l?i.removeRange([l.range[0]-1,l.range[1]]):i.insertTextBefore(t.matcher,"not."))}return a}})}}}}),Be="prefer-to-be-truthy",Hn=e=>e.type===r.Literal&&e.value===!0,Vn=m({name:Be,meta:{type:"suggestion",docs:{description:"enforce using `toBeTruthy`",recommended:!1},messages:{preferToBeTruthy:"Prefer using `toBeTruthy` to test value is `true`"},fixable:"code",schema:[]},defaultOptions:[],create(e){return{CallExpression(s){const t=g(s,e);(t?.type==="expect"||t?.type==="expectTypeOf")&&t.args.length===1&&Hn(P(t))&&B.hasOwnProperty(y(t.matcher))&&e.report({node:t.matcher,messageId:"preferToBeTruthy",fix:n=>[n.replaceText(t.matcher,"toBeTruthy"),n.remove(t.args[0])]})}}}}),Pe="prefer-to-be-falsy",Kn=e=>e.type===r.Literal&&e.value===!1,Xn=m({name:Pe,meta:{type:"suggestion",docs:{description:"enforce using toBeFalsy()",recommended:!1},fixable:"code",schema:[],messages:{preferToBeFalsy:"Prefer using toBeFalsy()"}},defaultOptions:[],create(e){return{CallExpression(s){const t=g(s,e);(t?.type==="expect"||t?.type==="expectTypeOf")&&t.args.length===1&&Kn(P(t))&&B.hasOwnProperty(y(t.matcher))&&e.report({node:t.matcher,messageId:"preferToBeFalsy",fix:n=>[n.replaceText(t.matcher,"toBeFalsy"),n.remove(t.args[0])]})}}}}),Ue="prefer-to-have-length",zn=m({name:Ue,meta:{type:"suggestion",docs:{description:"enforce using toHaveLength()",recommended:!1},fixable:"code",messages:{preferToHaveLength:"Prefer toHaveLength()"},schema:[]},defaultOptions:[],create(e){return{CallExpression(s){const t=g(s,e);if(t?.type!=="expect")return;const{parent:n}=t.head.node;if(n?.type!==r.CallExpression)return;const[o]=n.arguments,{matcher:i}=t;!B.hasOwnProperty(y(i))||o?.type!==r.MemberExpression||!v(o.property,"length")||e.report({node:i,messageId:"preferToHaveLength",fix(a){return[a.removeRange([o.property.range[0]-1,o.range[1]]),a.replaceTextRange([i.parent.object.range[1],i.parent.range[1]],".toHaveLength")]}})}}}}),je="prefer-equality-matcher",Yn=m({name:je,meta:{type:"suggestion",docs:{description:"enforce using the built-in quality matchers",recommended:!1},messages:{useEqualityMatcher:"Prefer using one of the equality matchers instead",suggestEqualityMatcher:"Use `{{ equalityMatcher }}`"},hasSuggestions:!0,schema:[]},defaultOptions:[],create(e){return{CallExpression(s){const t=g(s,e);if(t?.type!=="expect"||t.args.length===0)return;const{parent:n}=t.head.node;if(n?.type!==r.CallExpression)return;const{arguments:[o],range:[,i]}=n,{matcher:a}=t,c=P(t);if(o?.type!==r.BinaryExpression||o.operator!=="==="&&o.operator!=="!=="||!B.hasOwnProperty(y(a))||!se(c))return;const l=c.value,[d]=t.modifiers,f=t.modifiers.some(p=>y(p)==="not"),u=(o.operator==="!=="?!l:l)===f,x=p=>I=>{const{sourceCode:k}=e;let b=d&&y(d)!=="not"?`.${y(d)}`:"";return u&&(b+=`.${N.not}`),[I.replaceText(o,k.getText(o.left)),I.replaceTextRange([i,a.parent.range[1]],`${b}.${p}`),I.replaceText(c,k.getText(o.right))]};e.report({messageId:"useEqualityMatcher",suggest:["toBe","toEqual","toStrictEqual"].map(p=>({messageId:"suggestEqualityMatcher",data:{equalityMatcher:p},fix:x(p)})),node:a})}}}}),_e="prefer-strict-equal",Gn=m({name:_e,meta:{type:"suggestion",docs:{description:"enforce strict equal over equal",recommended:!1},messages:{useToStrictEqual:"Use `toStrictEqual()` instead",suggestReplaceWithStrictEqual:"Replace with `toStrictEqual()`"},schema:[],hasSuggestions:!0},defaultOptions:[],create(e){return{CallExpression(s){const t=g(s,e);if(t?.type!=="expect")return;const{matcher:n}=t;v(n,"toEqual")&&e.report({messageId:"useToStrictEqual",node:n,suggest:[{messageId:"suggestReplaceWithStrictEqual",fix:o=>[K(o,n,B.toStrictEqual)]}]})}}}}),We="prefer-expect-resolves",Jn=m({name:We,meta:{type:"suggestion",docs:{description:"enforce using `expect().resolves` over `expect(await ...)` syntax",recommended:!1},fixable:"code",messages:{expectResolves:"Use `expect().resolves` instead"},schema:[]},defaultOptions:[],create:e=>({CallExpression(s){const t=g(s,e);if(t?.type!=="expect")return;const{parent:n}=t.head.node;if(n?.type!==r.CallExpression)return;const[o]=n.arguments;o?.type===r.AwaitExpression&&e.report({node:o,messageId:"expectResolves",fix(i){return[i.insertTextBefore(n,"await "),i.removeRange([o.range[0],o.argument.range[0]]),i.insertTextAfter(n,".resolves")]}})}})}),De="prefer-each",Qn=m({name:De,meta:{type:"suggestion",docs:{description:"enforce using `each` rather than manual loops",recommended:!1},schema:[],messages:{preferEach:"Prefer using `{{ fn }}.each` rather than a manual loop"}},defaultOptions:[],create(e){const s=[];let t=!1;const n=()=>s.length===1&&s[0]==="test"?"it":"describe",o=()=>{s.length===0||t||(s.length=0)},i=a=>{s.length===0||t||(e.report({node:a,messageId:"preferEach",data:{fn:n()}}),s.length=0)};return{ForStatement:o,"ForStatement:exit":i,ForInStatement:o,"ForInStatement:exit":i,ForOfStatement:o,"ForOfStatement:exit":i,CallExpression(a){const{type:c}=g(a,e)??{};(c==="hook"||c==="describe"||c==="test")&&s.push(c),c==="test"&&(t=!0)},"CallExpression:exit"(a){const{type:c}=g(a,e)??{};c==="test"&&(t=!1)}}}}),He="prefer-hooks-on-top",Zn=m({name:He,meta:{type:"suggestion",docs:{description:"enforce having hooks before any test cases",recommended:!1},messages:{noHookOnTop:"Hooks should come before test cases"},schema:[]},defaultOptions:[],create(e){const s=[!1];return{CallExpression(t){E(t,e,["test"])&&(s[s.length-1]=!0),s[s.length-1]&&E(t,e,["hook"])&&e.report({messageId:"noHookOnTop",node:t}),s.push(!1)},"CallExpression:exit"(){s.pop()}}}}),Ve="prefer-hooks-in-order",Xt=["beforeAll","beforeEach","afterEach","afterAll"],eo=m({name:Ve,meta:{type:"suggestion",docs:{description:"enforce having hooks in consistent order",recommended:!1},messages:{reorderHooks:"`{{ currentHook }}` hooks should be before any `{{ previousHook }}` hooks"},schema:[]},defaultOptions:[],create(e){let s=-1,t=!1;return{CallExpression(n){if(t)return;const o=g(n,e);if(o?.type!=="hook"){s=-1;return}t=!0;const i=o.name,a=Xt.indexOf(i);if(a<s){e.report({messageId:"reorderHooks",data:{previousHook:Xt[s],currentHook:i},node:n}),t=!1;return}s=a},"CallExpression:exit"(n){if(E(n,e,["hook"])){t=!1;return}t||(s=-1)}}}}),Ke="prefer-mock-promise-shorthand",Xe=(e,s)=>`${e}${s?"Once":""}`,to=e=>e.body.type!==r.BlockStatement?e.body:e.body.body[0]?.type===r.ReturnStatement?e.body.body[0].argument:null,so=m({name:Ke,meta:{type:"suggestion",docs:{description:"enforce mock resolved/rejected shorthands for promises",recommended:!1},messages:{useMockShorthand:"Prefer {{ replacement }}"},schema:[],fixable:"code"},defaultOptions:[],create(e){const s=(t,n,o,i=o)=>{if(i?.type!==r.CallExpression)return;const a=R(i);if(a!=="Promise.resolve"&&a!=="Promise.reject")return;const c=Xe(a.endsWith("reject")?"mockRejectedValue":"mockResolvedValue",n);e.report({node:t,messageId:"useMockShorthand",data:{replacement:c},fix(l){const{sourceCode:d}=e;return i.arguments.length>1?null:[l.replaceText(t,c),l.replaceText(o,i.arguments.length===1?d.getText(i.arguments[0]):"undefined")]}})};return{CallExpression(t){if(t.callee.type!==r.MemberExpression||!v(t.callee.property)||t.arguments.length===0)return;const n=y(t.callee.property),o=n.endsWith("Once");if(n===Xe("mockReturnValue",o))s(t.callee.property,o,t.arguments[0]);else if(n===Xe("mockImplementation",o)){const[i]=t.arguments;if(!M(i)||i.params.length!==0)return;s(t.callee.property,o,i,to(i))}}}}}),no=xt(import.meta.url),oo=xt(no.resolve("eslint"));oo.resolve("espree");const ro=new Set([r.Program,r.BlockStatement,r.SwitchCase,r.SwitchStatement]),io=e=>ro.has(e),ao=e=>e.value===";"&&e.type===bt.Punctuator,zt=(e,s)=>{const t=e.getLastToken(s),n=e.getTokenBefore(t),o=e.getTokenAfter(t);return n&&o&&n.range[0]>=s.range[0]&&ao(t)&&t.loc.start.line!==n.loc.end.line&&t.loc.end.line===o.loc.start.line?n:t},co=(e,s,t)=>{const n=[];let o=zt(t,e);if(s.loc.start.line-e.loc.end.line>=2)do{const i=t.getTokenAfter(o,{includeComments:!0});i.loc.start.line-o.loc.end.line>=2&&n.push([o,i]),o=i}while(o.range[0]<s.range[0]);return n},Yt=(e,s)=>e.loc.end.line===s.loc.start.line,lo=e=>e.type===r.TSAsExpression||e.type===r.TSTypeAssertion,Gt=e=>lo(e)?Gt(e.expression):e,ze="prefer-vi-mocked",uo=["Mock","MockedFunction","MockedClass","MockedObject"],po=m({name:ze,meta:{type:"suggestion",docs:{description:"require `vi.mocked()` over `fn as Mock`",requiresTypeChecking:!0,recommended:!1},fixable:"code",messages:{useViMocked:"Prefer `vi.mocked()`"},schema:[]},defaultOptions:[],create(e){function s(t){const{typeAnnotation:n}=t;if(n.type!==r.TSTypeReference)return;const{typeName:o}=n;if(o.type!==r.Identifier||!uo.includes(o.name))return;const i=e.sourceCode.text.slice(...Gt(t.expression).range);e.report({node:t,messageId:"useViMocked",fix(a){return a.replaceText(t,`vi.mocked(${i})`)}})}return{TSAsExpression(t){t.parent.type!==r.TSAsExpression&&s(t)},TSTypeAssertion(t){s(t)}}}}),Ye="prefer-snapshot-hint",fo=["toMatchSnapshot","toThrowErrorMatchingSnapshot"],mo=fo,yo=e=>{if(e.args.length===0)return!0;if(!v(e.matcher,"toMatchSnapshot"))return e.args.length!==1;if(e.args.length===2)return!1;const[s]=e.args;return!L(s)},ho=m({name:Ye,meta:{type:"suggestion",docs:{description:"enforce including a hint with external snapshots",recommended:!1},messages:{missingHint:"You should provide a hint for this snapshot"},schema:[{type:"string",enum:["always","multi"]}]},defaultOptions:["multi"],create(e,[s]){const t=[];let n=0;const o=[],i=()=>{for(const l of t)yo(l)&&e.report({messageId:"missingHint",node:l.matcher})},a=()=>{n++},c=()=>{n--,s==="always"&&(i(),t.length=0),s==="multi"&&n===0&&(t.length>1&&i(),t.length=0)};return{"Program:exit"(){a(),c()},FunctionExpression:a,"FunctionExpression:exit":c,ArrowFunctionExpression:a,"ArrowFunctionExpression:exit":c,"CallExpression:exit"(l){E(l,e,["describe","test"])&&(n=o.pop()??0)},CallExpression(l){const d=g(l,e);if(d?.type!=="expect"){(d?.type==="describe"||d?.type==="test")&&(o.push(n),n=0);return}const f=y(d.matcher);mo.includes(f)&&t.push(d)}}}}),ne="valid-describe-callback",Jt=e=>{const[s]=e,t=e[e.length-1];return{start:s.loc.start,end:t.loc.end}},Qt=(e,s)=>e.members.every(t=>y(t)!=="each")&&s.params.length,Zt=(e,s)=>{e.body.forEach(t=>{t.type===r.ReturnStatement&&s.report({messageId:"unexpectedReturnInDescribe",node:t})})},go=m({name:ne,meta:{type:"problem",docs:{description:"enforce valid describe callback",recommended:!1},messages:{nameAndCallback:"Describe requires a name and callback arguments",secondArgumentMustBeFunction:"Second argument must be a function",unexpectedDescribeArgument:"Unexpected argument in describe callback",unexpectedReturnInDescribe:"Unexpected return statement in describe callback"},schema:[]},defaultOptions:[],create(e){return{CallExpression(s){const t=g(s,e);if(t?.type!=="describe"||t?.members[0]?.type===r.Identifier&&t.members[0].name==="todo")return;if(s.arguments.length<1)return e.report({messageId:"nameAndCallback",loc:s.loc});const[,n,o]=s.arguments;if(!n){e.report({messageId:"nameAndCallback",loc:Jt(s.arguments)});return}if(!M(n)){if(o&&M(o)){Qt(t,o)&&e.report({messageId:"unexpectedDescribeArgument",node:o}),o.body.type===r.CallExpression&&e.report({messageId:"unexpectedReturnInDescribe",node:o}),o.body.type===r.BlockStatement&&Zt(o.body,e);return}e.report({messageId:"secondArgumentMustBeFunction",loc:Jt(s.arguments)});return}Qt(t,n)&&e.report({messageId:"unexpectedDescribeArgument",node:n}),n.body.type===r.CallExpression&&e.report({messageId:"unexpectedReturnInDescribe",node:n}),n.body.type===r.BlockStatement&&Zt(n.body,e)}}}}),Ge="require-top-level-describe",ko=m({name:Ge,meta:{docs:{description:"enforce that all tests are in a top-level describe",recommended:!1},messages:{tooManyDescribes:"There should not be more than {{ max }} describe{{ s }} at the top level",unexpectedTestCase:"All test cases must be wrapped in a describe block",unexpectedHook:"All hooks must be wrapped in a describe block"},type:"suggestion",schema:[{type:"object",properties:{maxNumberOfTopLevelDescribes:{type:"number",minimum:1}},additionalProperties:!1}]},defaultOptions:[{}],create(e){const{maxNumberOfTopLevelDescribes:s=1/0}=e.options[0]??{};let t=0,n=0;return{CallExpression(o){const i=g(o,e);if(i){if(i.type==="describe"){n++,n===1&&(t++,t>s&&e.report({node:o,messageId:"tooManyDescribes",data:{max:s,s:s===1?"":"s"}}));return}if(n===0){if(i.type==="test"){e.report({node:o,messageId:"unexpectedTestCase"});return}i.type==="hook"&&e.report({node:o,messageId:"unexpectedHook"})}}},"CallExpression:exit"(o){E(o,e,["describe"])&&n--}}}}),Je="require-to-throw-message",bo=m({name:Je,meta:{type:"suggestion",docs:{description:"require toThrow() to be called with an error message",recommended:!1},schema:[],messages:{addErrorMessage:"Add an error message to {{ matcherName }}()"}},defaultOptions:[],create(e){return{CallExpression(s){const t=g(s,e);if(t?.type!=="expect")return;const{matcher:n}=t,o=y(n);t.args.length===0&&["toThrow","toThrowError"].includes(o)&&!t.modifiers.some(i=>y(i)==="not")&&e.report({messageId:"addErrorMessage",data:{matcherName:o},node:n})}}}}),Qe="require-hook",xo=(e,s)=>g(e,s)?!0:!!R(e)?.startsWith("vi"),Io=e=>e.type===r.Literal&&e.value===null||F(e,"undefined"),es=(e,s,t=[])=>{switch(e.type){case r.ExpressionStatement:return es(e.expression,s,t);case r.CallExpression:return!(xo(e,s)||t.includes(R(e)));case r.VariableDeclaration:return e.kind==="const"?!1:e.declarations.some(({init:n})=>n!==null&&!Io(n));default:return!1}},qo=m({name:Qe,meta:{docs:{description:"require setup and teardown to be within a hook",recommended:!1},messages:{useHook:"This should be done within a hook"},type:"suggestion",schema:[{type:"object",properties:{allowedFunctionCalls:{type:"array",items:{type:"string"}}},additionalProperties:!1}]},defaultOptions:[{allowedFunctionCalls:[]}],create(e){const{allowedFunctionCalls:s}=e.options[0]??{},t=n=>{for(const o of n)es(o,e,s)&&e.report({node:o,messageId:"useHook"})};return{Program(n){t(n.body)},CallExpression(n){if(!E(n,e,["describe"])||n.arguments.length<2)return;const[,o]=n.arguments;!M(o)||o.body.type!==r.BlockStatement||t(o.body.body)}}}}),oe="require-local-test-context-for-concurrent-snapshots",Eo=m({name:oe,meta:{docs:{description:"require local Test Context for concurrent snapshot tests",recommended:!1},messages:{requireLocalTestContext:"Use local Test Context instead"},type:"problem",schema:[]},defaultOptions:[],create(e){return{CallExpression(s){const t=g(s,e);t===null||t.type!=="expect"||t.type==="expect"&&t.head.type==="testContext"||!["toMatchSnapshot","toMatchInlineSnapshot","toMatchFileSnapshot","toThrowErrorMatchingSnapshot","toThrowErrorMatchingInlineSnapshot"].includes(s.callee?.property.name)||!e.sourceCode.getAncestors(s).some(n=>n.type!==r.CallExpression||!E(n,e,["describe","test"])?!1:n.callee.type===r.MemberExpression&&v(n.callee.property,"concurrent"))||e.report({node:s,messageId:"requireLocalTestContext"})}}}}),Ze="prefer-todo",To=e=>e.members.some(s=>y(s)!=="skip")||e.name.startsWith("x")?!1:!e.name.startsWith("f");function wo(e){return M(e)?e.body.type===r.BlockStatement&&!e.body.body.length:!1}function ts(e,s){return e.members.length?K(s,e.members[0],"todo"):s.replaceText(e.head.node,`${e.head.local}.todo`)}const Ao=m({name:Ze,meta:{type:"layout",docs:{description:"enforce using `test.todo`",recommended:!1},messages:{emptyTest:"Prefer todo test case over empty test case",unimplementedTest:"Prefer todo test case over unimplemented test case"},fixable:"code",schema:[]},defaultOptions:[],create(e){return{CallExpression(s){const[t,n]=s.arguments,o=g(s,e);!t||o?.type!=="test"||!To(o)||!L(t)||(n&&wo(n)&&e.report({messageId:"emptyTest",node:s,fix:i=>[i.removeRange([t.range[1],n.range[1]]),ts(o,i)]}),Kt(s)&&e.report({messageId:"unimplementedTest",node:s,fix:i=>ts(o,i)}))}}}}),et="prefer-spy-on",Co=e=>"object"in e?e.object:e.callee.type===r.MemberExpression?e.callee.object:null,ss=e=>{if(e.type!==r.CallExpression&&e.type!==r.MemberExpression)return null;const s=Co(e);return s?s.type===r.Identifier?e.type===r.CallExpression&&R(e.callee)==="vi.fn"?e:null:ss(s):null},vo=(e,s)=>{if(e.parent?.type===r.MemberExpression&&e.parent.property.type===r.Identifier&&e.parent.property.name==="mockImplementation")return"";const[t]=e.arguments,n=t&&s.sourceCode.getText(t);return n?`.mockImplementation(${n})`:".mockImplementation()"},So=m({name:et,meta:{type:"suggestion",docs:{description:"enforce using `vi.spyOn`",recommended:!1},messages:{useViSpayOn:"Use `vi.spyOn` instead"},fixable:"code",schema:[]},defaultOptions:[],create(e){return{AssignmentExpression(s){const{left:t,right:n}=s;if(t.type!==r.MemberExpression)return;const o=ss(n);o&&e.report({node:s,messageId:"useViSpayOn",fix(i){const a=t.property.type===r.Identifier&&!t.computed?"'":"",c=vo(o,e);return[i.insertTextBefore(t,"vi.spyOn("),i.replaceTextRange([t.object.range[1],t.property.range[0]],`, ${a}`),i.replaceTextRange([t.property.range[1],o.range[1]],`${a})${c}`)]}})}}}}),tt="prefer-comparison-matcher",ns=e=>L(e)||e?.type===r.TemplateLiteral,Mo=e=>ns(e.left)||ns(e.right),$o=e=>{switch(e){case">":return"<=";case"<":return">=";case">=":return"<";case"<=":return">"}return null},Oo=(e,s)=>{switch(s?$o(e):e){case">":return"toBeGreaterThan";case"<":return"toBeLessThan";case">=":return"toBeGreaterThanOrEqual";case"<=":return"toBeLessThanOrEqual"}return null},Ro=m({name:tt,meta:{type:"suggestion",docs:{description:"enforce using the built-in comparison matchers",recommended:!1},schema:[],fixable:"code",messages:{useToBeComparison:"Prefer using `{{ preferredMatcher }}` instead"}},defaultOptions:[],create(e){return{CallExpression(s){const t=g(s,e);if(t?.type!=="expect"||t.args.length===0)return;const{parent:n}=t.head.node;if(n?.type!==r.CallExpression)return;const{arguments:[o],range:[,i]}=n,{matcher:a}=t,c=P(t);if(o?.type!==r.BinaryExpression||Mo(o)||!B.hasOwnProperty(y(a))||!se(c))return;const[l]=t.modifiers,d=t.modifiers.some(u=>y(u)==="not"),f=Oo(o.operator,c.value===d);f&&e.report({fix(u){const{sourceCode:x}=e,p=l&&y(l)!=="not"?`.${y(l)}`:"";return[u.replaceText(o,x.getText(o.left)),u.replaceTextRange([i,a.parent.range[1]],`${p}.${f}`),u.replaceText(c,x.getText(o.right))]},messageId:"useToBeComparison",data:{preferredMatcher:f},node:a})}}}}),st="prefer-describe-function-title",No=m({name:st,meta:{type:"problem",docs:{description:"enforce using a function as a describe title over an equivalent string",recommended:!1},fixable:"code",schema:[],messages:{preferFunction:"Enforce using a function over an equivalent string"}},defaultOptions:[],create(e){return{CallExpression(s){if(s.arguments.length<2)return;const[t]=s.arguments;if(t.type!==r.Literal||typeof t.value!="string")return;const n=t.value;if(g(s,e)?.type!=="describe")return;const o=$s(e,s)?.set.get(n)?.defs[0];if(o?.type==="ImportBinding"){if(z(e.settings).typecheck){const i=re.getParserServices(e).getTypeAtLocation(o.node);if(!Et(i))return}e.report({node:t,messageId:"preferFunction",fix(i){return i.replaceText(t,n)}})}}}}}),nt="prefer-to-contain",Lo=e=>e.type===r.CallExpression&&e.callee.type===r.MemberExpression&&v(e.callee.property,"includes")&&Kt(e)&&e.arguments[0].type!==r.SpreadElement,Fo=m({name:nt,meta:{docs:{description:"enforce using toContain()",recommended:!1},messages:{useToContain:"Use toContain() instead"},fixable:"code",type:"suggestion",schema:[]},defaultOptions:[],create(e){return{CallExpression(s){const t=g(s,e);if(t?.type!=="expect"||t.args.length===0)return;const{parent:n}=t.head.node;if(n?.type!==r.CallExpression)return;const{arguments:[o],range:[,i]}=n,{matcher:a}=t,c=P(t);if(!o||c.type===r.SpreadElement||!B.hasOwnProperty(y(a))||!se(c)||!Lo(o))return;const l=t.modifiers.some(d=>y(d)==="not");e.report({fix(d){const{sourceCode:f}=e,u=c.value===l;return[d.removeRange([o.callee.property.range[0]-1,o.range[1]]),d.replaceTextRange([i,a.parent.range[1]],u?`.${N.not}.toContain`:".toContain"),d.replaceText(t.args[0],f.getText(o.arguments[0]))]},messageId:"useToContain",node:a})}}}}),os="prefer-expect-assertions",Bo=e=>{let s=e;for(;s;){if(s.parent?.type===r.BlockStatement)return s.parent.body[0]===s;if(s.parent?.type===r.ArrowFunctionExpression)return!0;s=s.parent}throw new Error("Could not find parent block statement")},rs=(e,s,t)=>({messageId:"suggestRemovingExtraArguments",fix:n=>It(n,e,s,t)}),Po=m({name:"prefer-expect-assertions",meta:{docs:{description:"enforce using expect assertions instead of callbacks",recommended:!1},messages:{hasAssertionsTakesNoArguments:"`expect.hasAssertions` expects no arguments",assertionsRequiresOneArgument:"`expect.assertions` excepts a single argument of type number",assertionsRequiresNumberArgument:"This argument should be a number",haveExpectAssertions:"Every test should have either `expect.assertions(<number of assertions>)` or `expect.hasAssertions()` as its first expression",suggestAddingHasAssertions:"Add `expect.hasAssertions()`",suggestAddingAssertions:"Add `expect.assertions(<number of assertions>)`",suggestRemovingExtraArguments:"Remove extra arguments"},type:"suggestion",hasSuggestions:!0,schema:[{type:"object",properties:{onlyFunctionsWithAsyncKeyword:{type:"boolean"},onlyFunctionsWithExpectInLoop:{type:"boolean"},onlyFunctionsWithExpectInCallback:{type:"boolean"}},additionalProperties:!1}]},defaultOptions:[{onlyFunctionsWithAsyncKeyword:!1,onlyFunctionsWithExpectInCallback:!1,onlyFunctionsWithExpectInLoop:!1}],create(e,[s]){let t=0,n=!1,o=!1,i=!1,a=null,c=!1,l=!1;const d=k=>!!(!s.onlyFunctionsWithAsyncKeyword&&!s.onlyFunctionsWithExpectInCallback&&!s.onlyFunctionsWithExpectInLoop||s.onlyFunctionsWithAsyncKeyword&&k.async||s.onlyFunctionsWithExpectInCallback&&n||s.onlyFunctionsWithExpectInLoop&&o);function f(k,b){if(y(k.members[0])==="hasAssertions"){k.args.length&&e.report({messageId:"hasAssertionsTakesNoArguments",node:k.matcher,suggest:[rs(e,b,0)]});return}if(k.args.length!==1){let{loc:w}=k.matcher;const T=[];k.args.length&&(w=k.args[1].loc,T.push(rs(e,b,1))),e.report({messageId:"assertionsRequiresOneArgument",suggest:T,loc:w});return}const[A]=k.args;A.type===r.Literal&&typeof A.value=="number"&&Number.isInteger(A.value)||e.report({messageId:"assertionsRequiresNumberArgument",node:A})}const u=()=>c&&t++,x=()=>c&&t--,p=()=>l=!0,I=()=>l=!1;return{FunctionExpression:u,"FunctionExpression:exit":x,ArrowFunctionExpression:u,"ArrowFunctionExpression:exit":x,ForStatement:p,"ForStatement:exit":I,ForInStatement:p,"ForInStatement:exit":I,ForOfStatement:p,"ForOfStatement:exit":I,CallExpression(k){const b=g(k,e);if(b?.type==="test"){c=!0;return}b?.head.type==="testContext"&&b.members[0].type===r.Identifier&&b.members[0].name==="expect"&&(a=`${b.head.local}`),b?.type==="expect"&&c&&(t===1&&Bo(k)&&b.head.node.parent?.type===r.MemberExpression&&b.members.length===1&&["assertions","hasAssertions"].includes(y(b.members[0]))&&(f(b,k),i=!0),l&&(o=!0),t>1&&(n=!0))},"CallExpression:exit"(k){if(!E(k,e,["test"])||(c=!1,k.arguments.length<2))return;const[,b]=k.arguments;if(!M(b)||!d(b))return;if(o=!1,n=!1,i){i=!1;return}const A=[];if(b.body.type===r.BlockStatement){const w=a?`${a}.`:"";A.push(["suggestAddingHasAssertions",`${w}expect.hasAssertions();`],["suggestAddingAssertions",`${w}expect.assertions();`])}e.report({messageId:"haveExpectAssertions",node:k,suggest:A.map(([w,T])=>({messageId:w,fix:C=>C.insertTextBeforeRange([b.body.range[0]+1,b.body.range[1]],T)}))})}}}});var S=(e=>(e[e.Any=0]="Any",e[e.Always=1]="Always",e))(S||{}),h=(e=>(e[e.Any=0]="Any",e[e.AfterAllToken=1]="AfterAllToken",e[e.AfterEachToken=2]="AfterEachToken",e[e.BeforeAllToken=3]="BeforeAllToken",e[e.BeforeEachToken=4]="BeforeEachToken",e[e.DescribeToken=5]="DescribeToken",e[e.ExpectToken=6]="ExpectToken",e[e.ExpectTypeOfToken=7]="ExpectTypeOfToken",e[e.FdescribeToken=8]="FdescribeToken",e[e.FitToken=9]="FitToken",e[e.ItToken=10]="ItToken",e[e.TestToken=11]="TestToken",e[e.XdescribeToken=12]="XdescribeToken",e[e.XitToken=13]="XitToken",e[e.XtestToken=14]="XtestToken",e))(h||{});const Uo=(e,s,t)=>{const{sourceCode:n,ruleContext:o}=t;co(e,s,n).length>0||o.report({node:s,messageId:"missingPadding",fix(i){let a=zt(n,e);const c=n.getFirstTokenBetween(a,s,{includeComments:!0,filter(d){return Yt(a,d)?(a=d,!1):!0}})||s,l=Yt(a,c)?`

`:`
`;return i.insertTextAfter(a,l)}})},jo={0:()=>!0,1:Uo},_o=()=>{let e=null;return{get prevNode(){return e.prevNode},set prevNode(s){e.prevNode=s},enter(){e={upper:e,prevNode:null}},exit(){e=e.upper}}},$=e=>(s,t)=>{let n=s;if(n.type===r.ExpressionStatement){n.expression.type===r.AwaitExpression&&(n=n.expression.argument);const o=t.getFirstToken(n);return o?.type===bt.Identifier&&o.value===e}return!1},Wo={0:()=>!0,1:$("afterAll"),2:$("afterEach"),3:$("beforeAll"),4:$("beforeEach"),5:$("describe"),6:$("expect"),7:$("expectTypeOf"),8:$("fdescribe"),9:$("fit"),10:$("it"),11:$("test"),12:$("xdescribe"),13:$("xit"),14:$("xtest")},ot=(e,s,t)=>{let n=e;const{sourceCode:o}=t;for(;n.type===r.LabeledStatement;)n=n.body;return Array.isArray(s)?s.some(i=>ot(n,i,t)):Wo[s](n,o)},Do=(e,s,t)=>{const{configs:n}=t,o=i=>jo[i](e,s,t);for(let i=n.length-1;i>=0;--i){const{prevStatementType:a,nextStatementType:c,paddingType:l}=n[i];if(ot(e,a,t)&&ot(s,c,t))return o(l)}return o(0)},is=(e,s)=>{const{scopeInfo:t}=s;io(e?.parent.type)&&(t.prevNode&&Do(t.prevNode,e,s),t.prevNode=e)},j=(e,s,t,n=!1)=>m({name:e,meta:{docs:{description:s},fixable:"whitespace",deprecated:n,messages:{missingPadding:"expect blank line before this statement"},schema:[],type:"suggestion"},defaultOptions:[],create(o){const i={ruleContext:o,sourceCode:o.sourceCode??o.getSourceCode(),scopeInfo:_o(),configs:t},{scopeInfo:a}=i;return{Program:a.enter,"Program:exit":a.exit,BlockStatement:a.enter,"BlockStatement:exit":a.exit,SwitchStatement:a.enter,"SwitchStatement:exit":a.exit,":statement":c=>is(c,i),SwitchCase(c){is(c,i),a.enter()},"SwitchCase:exit":a.exit}}}),rt="padding-around-after-all-blocks",as=[{paddingType:S.Always,prevStatementType:h.Any,nextStatementType:h.AfterAllToken},{paddingType:S.Always,prevStatementType:h.AfterAllToken,nextStatementType:h.Any}],Ho=j(rt,"Enforce padding around `afterAll` blocks",as),it="padding-around-after-each-blocks",cs=[{paddingType:S.Always,prevStatementType:h.Any,nextStatementType:h.AfterEachToken},{paddingType:S.Always,prevStatementType:h.AfterEachToken,nextStatementType:h.Any}],Vo=j(it,"Enforce padding around `afterEach` blocks",cs),at="padding-around-before-all-blocks",ls=[{paddingType:S.Always,prevStatementType:h.Any,nextStatementType:h.BeforeAllToken},{paddingType:S.Always,prevStatementType:h.BeforeAllToken,nextStatementType:h.Any}],Ko=j(at,"Enforce padding around `beforeAll` blocks",ls),ct="padding-around-before-each-blocks",us=[{paddingType:S.Always,prevStatementType:h.Any,nextStatementType:h.BeforeEachToken},{paddingType:S.Always,prevStatementType:h.BeforeEachToken,nextStatementType:h.Any}],Xo=j(ct,"Enforce padding around `beforeEach` blocks",us),lt="padding-around-describe-blocks",ps=[{paddingType:S.Always,prevStatementType:h.Any,nextStatementType:[h.DescribeToken,h.FdescribeToken,h.XdescribeToken]},{paddingType:S.Always,prevStatementType:[h.DescribeToken,h.FdescribeToken,h.XdescribeToken],nextStatementType:h.Any}],zo=j(lt,"Enforce padding around `describe` blocks",ps),ut="padding-around-expect-groups",ds=[{paddingType:S.Always,prevStatementType:h.Any,nextStatementType:h.ExpectToken},{paddingType:S.Always,prevStatementType:h.ExpectToken,nextStatementType:h.Any},{paddingType:S.Any,prevStatementType:h.ExpectToken,nextStatementType:h.ExpectToken},{paddingType:S.Always,prevStatementType:h.Any,nextStatementType:h.ExpectTypeOfToken},{paddingType:S.Always,prevStatementType:h.ExpectTypeOfToken,nextStatementType:h.Any},{paddingType:S.Any,prevStatementType:h.ExpectTypeOfToken,nextStatementType:h.ExpectTypeOfToken}],Yo=j(ut,"Enforce padding around `expect` groups",ds),pt="padding-around-test-blocks",fs=[{paddingType:S.Always,prevStatementType:h.Any,nextStatementType:[h.TestToken,h.ItToken,h.FitToken,h.XitToken,h.XtestToken]},{paddingType:S.Always,prevStatementType:[h.TestToken,h.ItToken,h.FitToken,h.XitToken,h.XtestToken],nextStatementType:h.Any}],Go=j(pt,"Enforce padding around `test` blocks",fs),dt="padding-around-all",Jo=j(dt,"Enforce padding around vitest functions",[...as,...cs,...ls,...us,...ps,...ds,...fs]),ft="valid-expect-in-promise",Qo=["toRejectWith","toResolveWith"],mt=e=>{if(e.type===r.CallExpression&&e.callee.type===r.MemberExpression&&v(e.callee.property)){if(e.arguments.length===0)return!1;switch(y(e.callee.property)){case"then":return e.arguments.length<3;case"catch":case"finally":return e.arguments.length<2}}return!1},Zo=(e,s)=>{const t=g(e,s);if(t?.type!=="test")return!1;const n=t.members.some(a=>y(a)==="each");if(n&&e.callee.type!==r.TaggedTemplateExpression)return!0;const[,o]=e.arguments,i=Number(n);return o&&M(o)&&o.params.length===1+i},ms=(e,s)=>{const{name:t}=s;if(e.argument===null)return!1;if(e.argument.type===r.CallExpression&&e.argument.arguments.length>0){const n=R(e.argument);if(["Promise.all","Promise.allSettled"].includes(n)){const[o]=e.argument.arguments;if(o.type===r.ArrayExpression&&o.elements.some(i=>i&&F(i,t)))return!0}if(["Promise.resolve","Promise.reject"].includes(n)&&e.argument.arguments.length===1)return F(e.argument.arguments[0],t)}return F(e.argument,t)},ys=(e,s)=>{for(const t of s)if(t?.type===r.AwaitExpression&&F(t.argument,e)||t?.type===r.ArrayExpression&&ys(e,t.elements))return!0;return!1},er=(e,s)=>{let t=s;for(;t;){if(t.type===r.CallExpression){if(ys(e,t.arguments))return!0;t=t.callee}if(t.type!==r.MemberExpression)break;t=t.object}return!1},tr=e=>{let s=e,t=e;for(;t&&(t.type===r.CallExpression&&(s=t,t=t.callee),t.type===r.MemberExpression);)t=t.object;return s},yt=(e,s,t)=>{const{name:n}=e;for(const o of s)if(!(o.range[0]<=e.range[0])){if(o.type===r.ReturnStatement)return ms(o,e);if(o.type===r.ExpressionStatement){if(o.expression.type===r.CallExpression){if(er(n,o.expression))return!0;const i=tr(o.expression),a=g(o.expression,t);if(a?.type==="expect"&&i.arguments.length>0&&F(i.arguments[0],n)&&a.members.some(c=>{const l=y(c);return l===N.resolves||l===N.rejects}))return!0}if(o.expression.type===r.AwaitExpression&&ms(o.expression,e))return!0;if(o.expression.type===r.AssignmentExpression){if(F(o.expression.left,n)&&R(o.expression.right)?.startsWith(`${n}.`)&&mt(o.expression.right))continue;break}}if(o.type===r.BlockStatement&&yt(e,o.body,t))return!0}return!1},hs=e=>{let s=e;for(;s;){if(s.type===r.BlockStatement)return s.body;s=s.parent}throw new Error("Could not find BlockStatement - please file a github issue at https://github.com/vitest-dev/eslint-plugin-vitest")},sr=(e,s)=>{let t=e;for(;t;){if(M(t))return t=t.parent,t?.type===r.CallExpression&&E(t,s,["test"]);t=t.parent}return!1},nr=(e,s)=>{const t=hs(e);return F(e.id)?yt(e.id,t,s):!0},or=m({name:ft,meta:{docs:{description:"require promises that have expectations in their chain to be valid"},messages:{expectInFloatingPromise:"This promise should either be returned or awaited to ensure the expects in its chain are called"},type:"suggestion",schema:[]},defaultOptions:[{alwaysAwait:!1,asyncMatchers:Qo,minArgs:1,maxArgs:1}],create(e){let s=!1;const t=[];return{CallExpression(n){if(Zo(n,e)){s=!0;return}if(mt(n)){t.unshift(!1);return}t.length>0&&E(n,e,["expect"])&&(t[0]=!0)},"CallExpression:exit"(n){if(s){E(n,e,["test"])&&(s=!1);return}if(!mt(n)||!t.shift())return;const{parent:o}=At(n);if(!(!o||!sr(o,e))){switch(o.type){case r.VariableDeclarator:{if(nr(o,e))return;break}case r.AssignmentExpression:{if(o.left.type===r.Identifier&&yt(o.left,hs(o),e))return;break}case r.ExpressionStatement:break;case r.ReturnStatement:case r.AwaitExpression:default:return}e.report({messageId:"expectInFloatingPromise",node:o})}}}}}),ht="prefer-strict-boolean-matchers",rr=m({name:ht,meta:{type:"suggestion",docs:{description:"enforce using `toBe(true)` and `toBe(false)` over matchers that coerce types to boolean",recommended:!1},messages:{preferToBeTrue:"Prefer using `toBe(true)` to test value is `true`",preferToBeFalse:"Prefer using `toBe(false)` to test value is `false`"},fixable:"code",schema:[]},defaultOptions:[],create(e){return{CallExpression(s){const t=g(s,e);if(!(t?.type==="expect"||t?.type==="expectTypeOf"))return;const n=y(t.matcher);n==="toBeFalsy"&&e.report({node:t.matcher,messageId:"preferToBeFalse",fix:o=>[o.replaceText(t.matcher,"toBe"),o.insertTextAfterRange([t.matcher.range[0],t.matcher.range[1]+1],"false")]}),n==="toBeTruthy"&&e.report({node:t.matcher,messageId:"preferToBeTrue",fix:o=>[o.replaceText(t.matcher,"toBe"),o.insertTextAfterRange([t.matcher.range[0],t.matcher.range[1]+1],"true")]})}}}}),gt="require-mock-type-parameters",ir=m({name:gt,meta:{type:"suggestion",docs:{description:"enforce using type parameters with vitest mock functions",recommended:!1},messages:{noTypeParameter:"Missing type parameters"},fixable:"code",schema:[{type:"object",properties:{checkImportFunctions:{type:"boolean"}},additionalProperties:!1}]},defaultOptions:[{checkImportFunctions:!1}],create(e,[s]){return{CallExpression(t){const n=g(t,e);if(n?.type==="vi")for(const o of n?.members)!("name"in o)||o.parent.parent.typeArguments!==void 0||(o.name==="fn"&&e.report({node:o,messageId:"noTypeParameter"}),s.checkImportFunctions&&["importActual","importMock"].includes(o.name)&&e.report({node:o,messageId:"noTypeParameter"}))}}}}),gs=e=>Object.keys(e).reduce((s,t)=>({...s,[`vitest/${t}`]:e[t]}),{}),ks=e=>({plugins:["@vitest"],rules:Object.keys(e).reduce((s,t)=>({...s,[`@vitest/${t}`]:e[t]}),{})}),bs={[le]:"warn",[ue]:"warn",[pe]:"warn",[me]:"warn",[ye]:"warn",[ke]:"warn",[be]:"warn",[xe]:"warn",[Ie]:"warn",[qe]:"warn",[Ee]:"warn",[Te]:"warn",[we]:"warn",[Ae]:"warn",[Ce]:"warn",[ve]:"warn",[Se]:"warn",[Me]:"warn",[$e]:"warn",[Oe]:"warn",[Re]:"warn",[Ne]:"warn",[Le]:"warn",[Pe]:"off",[Fe]:"warn",[Be]:"off",[Ue]:"warn",[je]:"warn",[_e]:"warn",[We]:"warn",[De]:"warn",[He]:"warn",[Ve]:"warn",[Ke]:"warn",[ze]:"warn",[Ye]:"warn",[Ge]:"warn",[Je]:"warn",[Qe]:"warn",[Ze]:"warn",[et]:"warn",[tt]:"warn",[st]:"warn",[nt]:"warn",[os]:"warn",[ge]:"warn",[rt]:"warn",[it]:"warn",[dt]:"warn",[at]:"warn",[ct]:"warn",[lt]:"warn",[ut]:"warn",[pt]:"warn",[ft]:"warn",[Y]:"warn",[X]:"warn",[J]:"warn",[Z]:"warn",[te]:"warn",[ne]:"warn",[oe]:"warn",[Q]:"warn",[ht]:"warn",[gt]:"warn"},xs={[Y]:"error",[X]:"error",[J]:"error",[Z]:"error",[te]:"error",[ne]:"error",[oe]:"error",[Q]:"error"},kt={meta:{name:"vitest",version:ws},rules:{[le]:Xs,[ue]:zs,[X]:Ys,[pe]:Gs,[me]:Js,[Y]:Zs,[ye]:sn,[ge]:cn,[ke]:ln,[be]:un,[xe]:pn,[Ie]:dn,[qe]:fn,[J]:yn,[Ee]:hn,[Te]:kn,[we]:bn,[Ae]:In,[Ce]:qn,[ve]:En,[Se]:Tn,[Me]:An,[$e]:vn,[Oe]:Sn,[Re]:Mn,[Ne]:On,[Q]:gn,[Le]:Rn,[Z]:Fn,[te]:jn,[Pe]:Xn,[Fe]:Dn,[Be]:Vn,[Ue]:zn,[je]:Yn,[_e]:Gn,[We]:Jn,[De]:Qn,[He]:Zn,[Ve]:eo,[oe]:Eo,[Ke]:so,[ze]:po,[Ye]:ho,[ne]:go,[Ge]:ko,[Je]:bo,[Qe]:qo,[Ze]:Ao,[et]:So,[tt]:Ro,[st]:No,[nt]:Fo,[os]:Po,[rt]:Ho,[it]:Vo,[dt]:Jo,[at]:Ko,[ct]:Xo,[lt]:zo,[ut]:Yo,[pt]:Go,[ft]:or,[ht]:rr,[gt]:ir},environments:{env:{globals:{suite:!0,test:!0,describe:!0,it:!0,expectTypeOf:!0,assertType:!0,expect:!0,assert:!0,chai:!0,vitest:!0,vi:!0,beforeAll:!0,afterAll:!0,beforeEach:!0,afterEach:!0,onTestFailed:!0,onTestFinished:!0}}},configs:{"legacy-recommended":ks(xs),"legacy-all":ks(bs),recommended:{name:"@vitest/recommended",plugins:{get vitest(){return kt}},rules:gs(xs)},all:{name:"@vitest/all",plugins:{get vitest(){return kt}},rules:gs(bs)},env:{name:"@vitest/env",languageOptions:{globals:{suite:"writable",test:"writable",describe:"writable",it:"writable",expectTypeOf:"writable",assertType:"writable",expect:"writable",assert:"writable",chai:"writable",vitest:"writable",vi:"writable",beforeAll:"writable",afterAll:"writable",beforeEach:"writable",afterEach:"writable",onTestFailed:"writable",onTestFinished:"writable"}}}}};export{kt as default};
